请实现PoE2智能构筑生成器的完整打包和分发系统：

## 23.1 打包架构设计

### 打包策略层次
```
┌─── Application Packaging Strategy ─────────────────────────────────┐
│  ┌─ PyInstaller Build ─────┐  ┌─ Resource Management ────────────┐ │
│  │ • 单文件/目录模式       │  │ • 静态资源打包                 │ │
│  │ • 依赖检测和包含        │  │ • 动态资源处理                 │ │
│  │ • 性能优化配置          │  │ • 压缩和加密                   │ │
│  └────────────────────────┘  └────────────────────────────────┘ │
└───────────────────────────────────────────────────────────────────┘
┌─── Distribution System ────────────────────────────────────────────┐
│  ┌─ Installer Creation ───┐  ┌─ Digital Signature ───────────────┐ │
│  │ • Inno Setup配置       │  │ • 代码签名证书                  │ │
│  │ • NSIS替代方案         │  │ • 时间戳服务器                  │ │
│  │ • MSI包生成            │  │ • 证书验证流程                  │ │
│  └───────────────────────┘  └────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────────────┘
┌─── Auto-Update System ─────────────────────────────────────────────┐
│  ┌─ Update Detection ─────┐  ┌─ Patch Distribution ──────────────┐ │
│  │ • 版本检查服务          │  │ • 增量更新支持                  │ │
│  │ • 更新通知机制          │  │ • 断点续传功能                  │ │
│  │ • 兼容性验证            │  │ • 回滚机制                      │ │
│  └───────────────────────┘  └────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────────────┘
```

### 项目打包结构
```
E:\zhakil\github\poe2build\packaging\
├── build_scripts/                     # 构建脚本
│   ├── build_exe.py                   # PyInstaller构建脚本
│   ├── build_installer.py             # 安装程序构建
│   ├── sign_executable.py             # 数字签名脚本
│   └── release_pipeline.py            # 发布流水线
├── pyinstaller/                       # PyInstaller配置
│   ├── poe2build.spec                 # 主规格文件
│   ├── hooks/                         # 自定义钩子
│   │   ├── hook-poe2build.py         # 应用钩子
│   │   ├── hook-pyqt6.py            # PyQt6钩子
│   │   └── hook-requests.py           # 第三方库钩子
│   ├── hidden_imports.py              # 隐藏导入
│   └── exclude_modules.py             # 排除模块
├── installer/                         # 安装程序配置
│   ├── inno_setup/                    # Inno Setup
│   │   ├── poe2build_installer.iss    # 安装脚本
│   │   ├── custom_pages.iss           # 自定义页面
│   │   ├── registry_setup.iss         # 注册表配置
│   │   └── uninstall_cleanup.iss      # 卸载清理
│   ├── nsis/                          # NSIS替代方案
│   │   ├── poe2build_installer.nsi    # NSIS脚本
│   │   └── custom_functions.nsh       # 自定义函数
│   └── wix/                           # WiX Toolset (MSI)
│       ├── product.wxs                # 产品定义
│       ├── features.wxs               # 功能定义
│       └── ui.wxs                     # 用户界面
├── resources/                         # 打包资源
│   ├── icons/                         # 图标文件
│   │   ├── app_icon.ico              # 应用图标
│   │   ├── installer_icon.ico         # 安装程序图标
│   │   └── uninstaller_icon.ico       # 卸载程序图标
│   ├── splash/                        # 启动画面
│   │   ├── installer_splash.bmp       # 安装启动画面
│   │   └── app_splash.png             # 应用启动画面
│   ├── docs/                          # 文档文件
│   │   ├── README.txt                 # 说明文档
│   │   ├── LICENSE.txt                # 许可证
│   │   ├── CHANGELOG.md               # 更新日志
│   │   └── INSTALL_GUIDE.md           # 安装指南
│   └── certificates/                  # 证书文件
│       ├── code_signing.p12           # 代码签名证书
│       └── timestamp_servers.txt      # 时间戳服务器
├── updater/                           # 自动更新系统
│   ├── update_client.py               # 更新客户端
│   ├── update_server.py               # 更新服务器
│   ├── patch_generator.py             # 补丁生成器
│   └── version_manager.py             # 版本管理
├── testing/                           # 打包测试
│   ├── test_installer.py              # 安装程序测试
│   ├── test_update.py                 # 更新功能测试
│   └── compatibility_test.py          # 兼容性测试
├── deployment/                        # 部署配置
│   ├── github_actions.yml             # GitHub Actions
│   ├── gitlab_ci.yml                  # GitLab CI
│   └── azure_pipelines.yml            # Azure Pipelines
└── dist/                              # 输出目录
    ├── exe/                           # 可执行文件
    ├── installer/                     # 安装程序
    ├── updates/                       # 更新包
    └── debug/                         # 调试版本
```

## 23.2 PyInstaller配置实现

### 主构建规格文件
```python
# packaging/pyinstaller/poe2build.spec

import os
import sys
from pathlib import Path

# 项目根目录
project_root = Path(__file__).parent.parent.parent
src_path = project_root / "src"
resources_path = project_root / "src" / "poe2build" / "gui" / "resources"

# 添加源码路径
sys.path.insert(0, str(src_path))

# 分析可执行文件
a = Analysis(
    # 主入口文件
    [str(project_root / "gui_main.py")],
    
    # 搜索路径
    pathex=[
        str(project_root),
        str(src_path),
        str(src_path / "poe2build"),
    ],
    
    # 二进制依赖
    binaries=[
        # PyQt6相关
        (r'C:\Python311\Lib\site-packages\PyQt6\Qt6\bin\Qt6Core.dll', '.'),
        (r'C:\Python311\Lib\site-packages\PyQt6\Qt6\bin\Qt6Gui.dll', '.'),
        (r'C:\Python311\Lib\site-packages\PyQt6\Qt6\bin\Qt6Widgets.dll', '.'),
    ],
    
    # 数据文件
    datas=[
        # GUI资源文件
        (str(resources_path / "themes"), "resources/themes"),
        (str(resources_path / "icons"), "resources/icons"),
        (str(resources_path / "images"), "resources/images"),
        (str(resources_path / "fonts"), "resources/fonts"),
        
        # 应用数据文件
        (str(project_root / "data" / "static"), "data/static"),
        (str(project_root / "requirements.txt"), "."),
        
        # 文档文件
        (str(project_root / "README.md"), "docs"),
        (str(project_root / "LICENSE"), "docs"),
    ],
    
    # 隐藏导入
    hiddenimports=[
        # PyQt6模块
        'PyQt6.QtCore',
        'PyQt6.QtGui', 
        'PyQt6.QtWidgets',
        'PyQt6.QtNetwork',
        'PyQt6.QtCharts',
        
        # 应用模块
        'poe2build.gui.app',
        'poe2build.gui.views',
        'poe2build.gui.components',
        'poe2build.gui.services',
        'poe2build.core',
        'poe2build.rag',
        'poe2build.pob2',
        
        # 第三方库
        'requests',
        'beautifulsoup4',
        'psutil',
        'numpy',
        'sklearn',
        
        # Windows特定
        'win32api',
        'win32con',
        'win32gui',
        'winreg',
    ],
    
    # 钩子目录
    hookspath=[str(Path(__file__).parent / "hooks")],
    
    # 运行时钩子
    hooksconfig={},
    
    # 排除的模块
    excludes=[
        # 开发工具
        'pytest',
        'black',
        'flake8',
        'mypy',
        
        # 不需要的标准库
        'tkinter',
        'turtle',
        'test',
        'unittest',
        'doctest',
        
        # 不需要的第三方库
        'matplotlib',
        'pandas',
        'jupyter',
        'notebook',
    ],
    
    # 不分析的模块
    noarchive=False,
    
    # 优化设置
    optimize=2,
)

# 过滤重复的二进制文件
pyz = PYZ(a.pure, a.zipped_data, cipher=None)

# 可执行文件配置
exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    
    # 输出文件名
    name='PoE2BuildGenerator',
    
    # 调试选项
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,  # UPX压缩
    upx_exclude=[
        "Qt6Core.dll",
        "Qt6Gui.dll", 
        "Qt6Widgets.dll",
    ],
    
    # 运行时选项
    runtime_tmpdir=None,
    console=False,  # 不显示控制台窗口
    disable_windowed_traceback=False,
    
    # 图标和版本信息
    icon=str(resources_path / "icons" / "app_icon.ico"),
    version=str(Path(__file__).parent / "version_info.txt"),
    
    # Windows特定设置
    uac_admin=False,  # 不需要管理员权限
    uac_uiaccess=False,
    
    # 输出目录 
    distpath=str(project_root / "packaging" / "dist" / "exe"),
    workpath=str(project_root / "packaging" / "build"),
    
    # 单文件模式
    onefile=True,
)

# 收集文件夹模式（可选）
coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='PoE2BuildGenerator_Folder',
    distpath=str(project_root / "packaging" / "dist" / "folder"),
)
```

### 版本信息文件
```python
# packaging/pyinstaller/version_info.txt

VSVersionInfo(
  ffi=FixedFileInfo(
    filevers=(1, 0, 0, 0),
    prodvers=(1, 0, 0, 0),
    mask=0x3f,
    flags=0x0,
    OS=0x40004,
    fileType=0x1,
    subtype=0x0,
    date=(0, 0)
  ),
  kids=[
    StringFileInfo(
      [
        StringTable(
          u'040904B0',
          [
            StringStruct(u'CompanyName', u'PoE2 Build Generator Team'),
            StringStruct(u'FileDescription', u'PoE2智能构筑生成器'),
            StringStruct(u'FileVersion', u'1.0.0.0'),
            StringStruct(u'InternalName', u'PoE2BuildGenerator'),
            StringStruct(u'LegalCopyright', u'Copyright (c) 2024 PoE2 Build Generator Team'),
            StringStruct(u'OriginalFilename', u'PoE2BuildGenerator.exe'),
            StringStruct(u'ProductName', u'PoE2智能构筑生成器'),
            StringStruct(u'ProductVersion', u'1.0.0.0'),
          ]
        )
      ]
    ),
    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])
  ]
)
```

### 自定义钩子实现
```python
# packaging/pyinstaller/hooks/hook-poe2build.py

from PyInstaller.utils.hooks import collect_all, collect_data_files, collect_submodules

# 收集所有poe2build相关文件
datas, binaries, hiddenimports = collect_all('poe2build')

# 添加GUI资源文件
gui_datas = collect_data_files('poe2build.gui.resources')
datas.extend(gui_datas)

# 收集所有子模块
gui_hiddenimports = collect_submodules('poe2build.gui')
hiddenimports.extend(gui_hiddenimports)

# 添加特定的隐藏导入
additional_hiddenimports = [
    'poe2build.gui.app',
    'poe2build.gui.main_window', 
    'poe2build.gui.views.welcome_page',
    'poe2build.gui.views.build_generator_page',
    'poe2build.gui.views.results_page',
    'poe2build.gui.components.poe2_theme',
    'poe2build.gui.components.build_card',
    'poe2build.gui.components.class_selector',
]

hiddenimports.extend(additional_hiddenimports)
```

### 构建脚本实现
```python
# packaging/build_scripts/build_exe.py

import os
import sys
import subprocess
import shutil
from pathlib import Path
import logging

# 配置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class PyInstallerBuilder:
    """PyInstaller构建器"""
    
    def __init__(self, project_root):
        self.project_root = Path(project_root)
        self.packaging_dir = self.project_root / "packaging"
        self.spec_file = self.packaging_dir / "pyinstaller" / "poe2build.spec"
        self.dist_dir = self.packaging_dir / "dist"
        self.build_dir = self.packaging_dir / "build"
        
    def clean_build(self):
        """清理构建目录"""
        logger.info("Cleaning build directories...")
        
        dirs_to_clean = [self.dist_dir, self.build_dir]
        
        for dir_path in dirs_to_clean:
            if dir_path.exists():
                shutil.rmtree(dir_path)
                logger.info(f"Cleaned {dir_path}")
                
        # 重新创建目录
        self.dist_dir.mkdir(parents=True, exist_ok=True)
        self.build_dir.mkdir(parents=True, exist_ok=True)
        
    def check_dependencies(self):
        """检查依赖项"""
        logger.info("Checking dependencies...")
        
        required_packages = [
            'pyinstaller',
            'PyQt6',
            'requests',
            'beautifulsoup4',
            'psutil'
        ]
        
        missing_packages = []
        
        for package in required_packages:
            try:
                __import__(package)
                logger.info(f"✓ {package} found")
            except ImportError:
                missing_packages.append(package)
                logger.error(f"✗ {package} missing")
                
        if missing_packages:
            logger.error(f"Missing packages: {missing_packages}")
            logger.error("Please install missing packages and try again")
            return False
            
        return True
        
    def build_executable(self, mode="onefile"):
        """构建可执行文件"""
        logger.info(f"Building executable in {mode} mode...")
        
        # 检查spec文件
        if not self.spec_file.exists():
            logger.error(f"Spec file not found: {self.spec_file}")
            return False
            
        # 构建PyInstaller命令
        cmd = [
            sys.executable, "-m", "PyInstaller",
            "--clean",  # 清理缓存
            "--noconfirm",  # 不询问覆盖
            str(self.spec_file)
        ]
        
        # 添加额外选项
        if mode == "debug":
            cmd.extend(["--debug", "all"])
            cmd.extend(["--console"])
        elif mode == "onedir":
            # 修改spec文件以生成目录模式
            pass
            
        logger.info(f"Running command: {' '.join(cmd)}")
        
        try:
            # 执行构建
            result = subprocess.run(
                cmd, 
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=1800  # 30分钟超时
            )
            
            if result.returncode == 0:
                logger.info("Build completed successfully!")
                logger.info(f"Output directory: {self.dist_dir}")
                
                # 显示构建统计信息
                self._show_build_stats()
                
                return True
            else:
                logger.error("Build failed!")
                logger.error(f"Error output: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            logger.error("Build timed out after 30 minutes")
            return False
        except Exception as e:
            logger.error(f"Build failed with exception: {e}")
            return False
            
    def _show_build_stats(self):
        """显示构建统计信息"""
        exe_path = self.dist_dir / "exe" / "PoE2BuildGenerator.exe"
        
        if exe_path.exists():
            size_mb = exe_path.stat().st_size / (1024 * 1024)
            logger.info(f"Executable size: {size_mb:.2f} MB")
            logger.info(f"Executable path: {exe_path}")
        else:
            logger.warning("Executable not found in expected location")
            
        # 检查其他输出文件
        folder_path = self.dist_dir / "folder" / "PoE2BuildGenerator_Folder"
        if folder_path.exists():
            folder_size = sum(f.stat().st_size for f in folder_path.rglob('*') if f.is_file())
            folder_size_mb = folder_size / (1024 * 1024)
            logger.info(f"Folder distribution size: {folder_size_mb:.2f} MB")
            
    def optimize_build(self):
        """优化构建结果"""
        logger.info("Optimizing build...")
        
        exe_path = self.dist_dir / "exe" / "PoE2BuildGenerator.exe"
        
        if not exe_path.exists():
            logger.warning("Executable not found for optimization")
            return False
            
        original_size = exe_path.stat().st_size
        
        try:
            # 使用UPX压缩（如果可用）
            if shutil.which("upx"):
                logger.info("Applying UPX compression...")
                subprocess.run([
                    "upx", "--best", "--lzma", str(exe_path)
                ], check=True, capture_output=True)
                
                new_size = exe_path.stat().st_size
                compression_ratio = (1 - new_size / original_size) * 100
                logger.info(f"UPX compression: {compression_ratio:.1f}% reduction")
            else:
                logger.info("UPX not available, skipping compression")
                
        except subprocess.CalledProcessError as e:
            logger.warning(f"UPX compression failed: {e}")
            
        return True
        
    def run_tests(self):
        """运行构建后测试"""
        logger.info("Running post-build tests...")
        
        exe_path = self.dist_dir / "exe" / "PoE2BuildGenerator.exe"
        
        if not exe_path.exists():
            logger.error("Executable not found for testing")
            return False
            
        try:
            # 测试可执行文件是否能启动
            result = subprocess.run([
                str(exe_path), "--version"
            ], capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                logger.info("✓ Executable launches successfully")
                logger.info(f"Version output: {result.stdout.strip()}")
                return True
            else:
                logger.error("✗ Executable failed to launch")
                logger.error(f"Error: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            logger.error("✗ Executable startup timed out")
            return False
        except Exception as e:
            logger.error(f"✗ Test failed: {e}")
            return False

def main():
    """主函数"""
    project_root = Path(__file__).parent.parent.parent
    builder = PyInstallerBuilder(project_root)
    
    # 解析命令行参数
    import argparse
    
    parser = argparse.ArgumentParser(description="Build PoE2 Build Generator executable")
    parser.add_argument("--mode", choices=["onefile", "onedir", "debug"], 
                       default="onefile", help="Build mode")
    parser.add_argument("--clean", action="store_true", help="Clean build directories first")
    parser.add_argument("--optimize", action="store_true", help="Optimize build result")
    parser.add_argument("--test", action="store_true", help="Run post-build tests")
    
    args = parser.parse_args()
    
    try:
        # 清理构建目录
        if args.clean:
            builder.clean_build()
            
        # 检查依赖
        if not builder.check_dependencies():
            sys.exit(1)
            
        # 构建可执行文件
        if not builder.build_executable(args.mode):
            sys.exit(1)
            
        # 优化构建
        if args.optimize:
            builder.optimize_build()
            
        # 运行测试
        if args.test:
            if not builder.run_tests():
                sys.exit(1)
                
        logger.info("Build process completed successfully!")
        
    except KeyboardInterrupt:
        logger.info("Build cancelled by user")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Build failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

## 23.3 Inno Setup安装程序

### 主安装脚本
```inno
; packaging/installer/inno_setup/poe2build_installer.iss

#define MyAppName "PoE2智能构筑生成器"
#define MyAppVersion "1.0.0"
#define MyAppPublisher "PoE2 Build Generator Team"
#define MyAppURL "https://github.com/your-repo/poe2build"
#define MyAppExeName "PoE2BuildGenerator.exe"
#define MyAppId "{{B4C4C4C4-5D5D-5E5E-5F5F-606060606060}"

[Setup]
; 基本信息
AppId={#MyAppId}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={autopf}\{#MyAppName}
DefaultGroupName={#MyAppName}
AllowNoIcons=yes
LicenseFile=..\..\resources\docs\LICENSE.txt
InfoBeforeFile=..\..\resources\docs\README.txt
InfoAfterFile=..\..\resources\docs\INSTALL_GUIDE.md
OutputDir=..\dist\installer
OutputBaseFilename=PoE2BuildGenerator_Setup_v{#MyAppVersion}
SetupIconFile=..\..\resources\icons\installer_icon.ico
WizardImageFile=..\..\resources\splash\installer_splash.bmp
Compression=lzma2
SolidCompression=yes
WizardStyle=modern

; 系统要求
MinVersion=10.0.10240
ArchitecturesAllowed=x64
ArchitecturesInstallIn64BitMode=x64

; 权限设置
PrivilegesRequired=lowest
PrivilegesRequiredOverridesAllowed=dialog

; 目录和文件
DisableProgramGroupPage=yes
DisableReadyPage=no
DisableFinishedPage=no

[Languages]
Name: "chinesesimp"; MessagesFile: "compiler:Languages\ChineseSimplified.isl"
Name: "english"; MessagesFile: "compiler:Default.isl"

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked
Name: "quicklaunchicon"; Description: "{cm:CreateQuickLaunchIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked; OnlyBelowVersion: 6.1; Check: not IsAdminLoggedOn
Name: "associatefiles"; Description: "关联.poe2build文件"; GroupDescription: "文件关联:"
Name: "startmenu"; Description: "添加到开始菜单"; GroupDescription: "{cm:AdditionalIcons}"
Name: "startup"; Description: "开机自动启动"; GroupDescription: "启动选项:"; Flags: unchecked

[Files]
; 主程序文件
Source: "..\dist\exe\PoE2BuildGenerator.exe"; DestDir: "{app}"; Flags: ignoreversion
Source: "..\resources\docs\*"; DestDir: "{app}\docs"; Flags: ignoreversion recursesubdirs createallsubdirs
Source: "..\resources\icons\app_icon.ico"; DestDir: "{app}"; Flags: ignoreversion

; 运行时依赖（如果使用文件夹模式）
; Source: "..\dist\folder\PoE2BuildGenerator_Folder\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs

[Icons]
Name: "{group}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; IconFilename: "{app}\app_icon.ico"
Name: "{group}\{cm:UninstallProgram,{#MyAppName}}"; Filename: "{uninstallexe}"; IconFilename: "{app}\app_icon.ico"
Name: "{autodesktop}\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: desktopicon; IconFilename: "{app}\app_icon.ico"
Name: "{userappdata}\Microsoft\Internet Explorer\Quick Launch\{#MyAppName}"; Filename: "{app}\{#MyAppExeName}"; Tasks: quicklaunchicon; IconFilename: "{app}\app_icon.ico"

[Run]
Filename: "{app}\{#MyAppExeName}"; Description: "{cm:LaunchProgram,{#StringChange(MyAppName, '&', '&&')}}"; Flags: nowait postinstall skipifsilent

[UninstallDelete]
Type: files; Name: "{app}\*.log"
Type: files; Name: "{app}\*.tmp"
Type: filesandordirs; Name: "{localappdata}\{#MyAppName}"
Type: dirifempty; Name: "{app}"

[Registry]
; 文件关联
Root: HKCU; Subkey: "Software\Classes\.poe2build"; ValueType: string; ValueName: ""; ValueData: "PoE2BuildFile"; Flags: uninsdeletevalue; Tasks: associatefiles
Root: HKCU; Subkey: "Software\Classes\PoE2BuildFile"; ValueType: string; ValueName: ""; ValueData: "PoE2构筑文件"; Flags: uninsdeletekey; Tasks: associatefiles
Root: HKCU; Subkey: "Software\Classes\PoE2BuildFile\DefaultIcon"; ValueType: string; ValueName: ""; ValueData: "{app}\app_icon.ico"; Flags: uninsdeletekey; Tasks: associatefiles
Root: HKCU; Subkey: "Software\Classes\PoE2BuildFile\shell\open\command"; ValueType: string; ValueName: ""; ValueData: """{app}\{#MyAppExeName}"" ""%1"""; Flags: uninsdeletekey; Tasks: associatefiles

; 应用程序注册
Root: HKCU; Subkey: "Software\{#MyAppName}"; ValueType: string; ValueName: "InstallPath"; ValueData: "{app}"; Flags: uninsdeletekey
Root: HKCU; Subkey: "Software\{#MyAppName}"; ValueType: string; ValueName: "Version"; ValueData: "{#MyAppVersion}"; Flags: uninsdeletekey
Root: HKCU; Subkey: "Software\{#MyAppName}"; ValueType: dword; ValueName: "Installed"; ValueData: 1; Flags: uninsdeletekey

; 开机启动
Root: HKCU; Subkey: "Software\Microsoft\Windows\CurrentVersion\Run"; ValueType: string; ValueName: "{#MyAppName}"; ValueData: """{app}\{#MyAppExeName}"" --startup"; Tasks: startup; Flags: uninsdeletevalue

[Code]
var
  OptionsPage: TInputOptionWizardPage;
  DataDirPage: TInputDirWizardPage;
  
procedure InitializeWizard;
begin
  { 创建自定义选项页面 }
  OptionsPage := CreateInputOptionPage(wpLicense,
    '安装选项', '选择额外的安装选项',
    '请选择您希望的安装选项：',
    True, False);
  
  OptionsPage.Add('创建桌面快捷方式');
  OptionsPage.Add('关联.poe2build文件');
  OptionsPage.Add('开机自动启动（最小化到系统托盘）');
  OptionsPage.Add('加入Windows Defender排除列表');
  
  { 创建数据目录选择页面 }
  DataDirPage := CreateInputDirPage(OptionsPage.ID,
    '数据目录', '选择应用程序数据存储目录',
    '选择{#MyAppName}存储配置文件和缓存数据的目录。',
    False, '');
  DataDirPage.Add('应用数据目录:');
  DataDirPage.Values[0] := ExpandConstant('{localappdata}\{#MyAppName}');
end;

function ShouldSkipPage(PageID: Integer): Boolean;
begin
  Result := False;
end;

procedure CurStepChanged(CurStep: TSetupStep);
var
  ResultCode: Integer;
begin
  if CurStep = ssPostInstall then
  begin
    { 创建数据目录 }
    if not DirExists(DataDirPage.Values[0]) then
      ForceDirectories(DataDirPage.Values[0]);
    
    { 添加Windows Defender排除项 }
    if OptionsPage.Values[3] then
    begin
      Exec('powershell.exe', 
           Format('-Command "Add-MpPreference -ExclusionPath ''%s''"', [ExpandConstant('{app}')]), 
           '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
    end;
    
    { 注册卸载信息 }
    RegWriteStringValue(HKEY_CURRENT_USER, 
                        'Software\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppId}',
                        'DisplayName', '{#MyAppName}');
    RegWriteStringValue(HKEY_CURRENT_USER,
                        'Software\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppId}',
                        'DisplayVersion', '{#MyAppVersion}');
    RegWriteStringValue(HKEY_CURRENT_USER,
                        'Software\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppId}',
                        'Publisher', '{#MyAppPublisher}');
    RegWriteStringValue(HKEY_CURRENT_USER,
                        'Software\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppId}',
                        'InstallLocation', ExpandConstant('{app}'));
    RegWriteStringValue(HKEY_CURRENT_USER,
                        'Software\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppId}',
                        'UninstallString', ExpandConstant('{uninstallexe}'));
  end;
end;

procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
var
  DataDir: string;
  ResultCode: Integer;
begin
  if CurUninstallStep = usPostUninstall then
  begin
    { 清理数据目录 }
    if RegQueryStringValue(HKEY_CURRENT_USER, 'Software\{#MyAppName}', 'DataDir', DataDir) then
    begin
      if DirExists(DataDir) then
      begin
        if MsgBox('是否删除应用程序数据和配置文件？' + #13#10 + 
                  '目录: ' + DataDir, mbConfirmation, MB_YESNO) = IDYES then
        begin
          DelTree(DataDir, True, True, True);
        end;
      end;
    end;
    
    { 移除Windows Defender排除项 }
    Exec('powershell.exe', 
         Format('-Command "Remove-MpPreference -ExclusionPath ''%s''" -ErrorAction SilentlyContinue', [ExpandConstant('{app}')]), 
         '', SW_HIDE, ewWaitUntilTerminated, ResultCode);
    
    { 清理注册表 }
    RegDeleteKeyIncludingSubkeys(HKEY_CURRENT_USER, 'Software\{#MyAppName}');
  end;
end;

function GetUninstallString(): String;
var
  sUnInstPath: String;
  sUnInstallString: String;
begin
  sUnInstPath := ExpandConstant('Software\Microsoft\Windows\CurrentVersion\Uninstall\{#MyAppId}_is1');
  sUnInstallString := '';
  if not RegQueryStringValue(HKLM, sUnInstPath, 'UninstallString', sUnInstallString) then
    RegQueryStringValue(HKCU, sUnInstPath, 'UninstallString', sUnInstallString);
  Result := sUnInstallString;
end;

function IsUpgrade(): Boolean;
begin
  Result := (GetUninstallString() <> '');
end;

function UnInstallOldVersion(): Integer;
var
  sUnInstallString: String;
  iResultCode: Integer;
begin
  Result := 0;
  sUnInstallString := GetUninstallString();
  if sUnInstallString <> '' then begin
    sUnInstallString := RemoveQuotes(sUnInstallString);
    if Exec(sUnInstallString, '/SILENT /NORESTART /SUPPRESSMSGBOXES','', SW_HIDE, ewWaitUntilTerminated, iResultCode) then
      Result := 3
    else
      Result := 2;
  end else
    Result := 1;
end;

procedure CurPageChanged(CurPageID: Integer);
begin
  if (CurPageID = wpWelcome) then
  begin
    if IsUpgrade() then
    begin
      if MsgBox('检测到已安装的版本。是否要升级到新版本？', mbConfirmation, MB_YESNO) = IDYES then
      begin
        UnInstallOldVersion();
      end else begin
        WizardForm.Close();
      end;
    end;
  end;
end;
```

## 23.4 数字签名系统

### 代码签名脚本
```python
# packaging/build_scripts/sign_executable.py

import os
import sys
import subprocess
import logging
from pathlib import Path
import tempfile

logger = logging.getLogger(__name__)

class CodeSigner:
    """代码签名器"""
    
    def __init__(self, certificate_path, password, timestamp_url=None):
        self.certificate_path = Path(certificate_path)
        self.password = password
        self.timestamp_url = timestamp_url or "http://timestamp.digicert.com"
        
        # 检查签名工具
        self.signtool_path = self._find_signtool()
        
    def _find_signtool(self):
        """查找signtool.exe"""
        possible_paths = [
            r"C:\Program Files (x86)\Windows Kits\10\bin\x64\signtool.exe",
            r"C:\Program Files (x86)\Windows Kits\10\bin\x86\signtool.exe",
            r"C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\signtool.exe",
        ]
        
        for path in possible_paths:
            if os.path.exists(path):
                return path
                
        # 检查PATH环境变量
        if shutil.which("signtool"):
            return "signtool"
            
        raise FileNotFoundError("signtool.exe not found. Please install Windows SDK.")
        
    def sign_file(self, file_path, description=None):
        """签名单个文件"""
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File to sign not found: {file_path}")
            
        if not self.certificate_path.exists():
            raise FileNotFoundError(f"Certificate file not found: {self.certificate_path}")
            
        # 构建signtool命令
        cmd = [
            self.signtool_path, "sign",
            "/f", str(self.certificate_path),
            "/p", self.password,
            "/t", self.timestamp_url,
            "/fd", "SHA256",
            "/td", "SHA256",
            "/v",  # 详细输出
        ]
        
        if description:
            cmd.extend(["/d", description])
            
        cmd.append(str(file_path))
        
        logger.info(f"Signing file: {file_path}")
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300  # 5分钟超时
            )
            
            if result.returncode == 0:
                logger.info(f"Successfully signed: {file_path}")
                return True
            else:
                logger.error(f"Failed to sign {file_path}")
                logger.error(f"Error: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            logger.error("Signing timed out")
            return False
        except Exception as e:
            logger.error(f"Signing failed: {e}")
            return False
            
    def verify_signature(self, file_path):
        """验证文件签名"""
        cmd = [
            self.signtool_path, "verify",
            "/pa",  # 使用默认验证策略
            "/v",   # 详细输出
            str(file_path)
        ]
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                logger.info(f"Signature verified: {file_path}")
                return True
            else:
                logger.warning(f"Signature verification failed: {file_path}")
                logger.warning(f"Output: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"Verification failed: {e}")
            return False
            
    def sign_installer(self, installer_path):
        """签名安装程序"""
        return self.sign_file(
            installer_path,
            description="PoE2智能构筑生成器安装程序"
        )
        
    def sign_executable(self, exe_path):
        """签名可执行文件"""
        return self.sign_file(
            exe_path,
            description="PoE2智能构筑生成器"
        )

def main():
    """主函数"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Sign executables and installers")
    parser.add_argument("--cert", required=True, help="Certificate file path")
    parser.add_argument("--password", required=True, help="Certificate password")
    parser.add_argument("--timestamp", help="Timestamp server URL")
    parser.add_argument("--exe", help="Executable file to sign")
    parser.add_argument("--installer", help="Installer file to sign")
    parser.add_argument("--verify", action="store_true", help="Verify signatures")
    
    args = parser.parse_args()
    
    try:
        signer = CodeSigner(args.cert, args.password, args.timestamp)
        
        success = True
        
        if args.exe:
            if not signer.sign_executable(args.exe):
                success = False
            elif args.verify:
                if not signer.verify_signature(args.exe):
                    success = False
                    
        if args.installer:
            if not signer.sign_installer(args.installer):
                success = False
            elif args.verify:
                if not signer.verify_signature(args.installer):
                    success = False
                    
        if success:
            logger.info("All signing operations completed successfully")
            sys.exit(0)
        else:
            logger.error("One or more signing operations failed")
            sys.exit(1)
            
    except Exception as e:
        logger.error(f"Signing failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

## 23.5 自动更新系统

### 更新客户端实现
```python
# packaging/updater/update_client.py

import os
import sys
import json
import requests
import hashlib
import tempfile
import subprocess
from pathlib import Path
from PyQt6.QtCore import QObject, QThread, pyqtSignal
import logging

logger = logging.getLogger(__name__)

class UpdateChecker(QObject):
    """更新检查器"""
    
    update_available = pyqtSignal(dict)  # 更新信息
    no_update_available = pyqtSignal()
    check_failed = pyqtSignal(str)       # 错误信息
    
    def __init__(self, current_version, update_url, parent=None):
        super().__init__(parent)
        self.current_version = current_version
        self.update_url = update_url
        self.update_info = None
        
    def check_for_updates(self):
        """检查更新"""
        try:
            logger.info("Checking for updates...")
            
            # 获取更新信息
            response = requests.get(
                f"{self.update_url}/version_info.json",
                timeout=10,
                headers={'User-Agent': 'PoE2BuildGenerator-Updater'}
            )
            response.raise_for_status()
            
            update_info = response.json()
            
            # 比较版本
            latest_version = update_info.get('version')
            if self._is_newer_version(latest_version, self.current_version):
                logger.info(f"Update available: {latest_version}")
                self.update_info = update_info
                self.update_available.emit(update_info)
            else:
                logger.info("No updates available")
                self.no_update_available.emit()
                
        except Exception as e:
            logger.error(f"Update check failed: {e}")
            self.check_failed.emit(str(e))
            
    def _is_newer_version(self, latest, current):
        """比较版本号"""
        try:
            latest_parts = [int(x) for x in latest.split('.')]
            current_parts = [int(x) for x in current.split('.')]
            
            # 补齐长度
            max_len = max(len(latest_parts), len(current_parts))
            latest_parts.extend([0] * (max_len - len(latest_parts)))
            current_parts.extend([0] * (max_len - len(current_parts)))
            
            return latest_parts > current_parts
        except:
            return False

class UpdateDownloader(QThread):
    """更新下载器"""
    
    progress_updated = pyqtSignal(int)   # 进度百分比
    download_completed = pyqtSignal(str) # 下载文件路径
    download_failed = pyqtSignal(str)    # 错误信息
    
    def __init__(self, update_info, download_dir, parent=None):
        super().__init__(parent)
        self.update_info = update_info
        self.download_dir = Path(download_dir)
        self.download_path = None
        self.cancelled = False
        
    def run(self):
        """执行下载"""
        try:
            download_url = self.update_info.get('download_url')
            if not download_url:
                self.download_failed.emit("Download URL not found")
                return
                
            # 创建下载目录
            self.download_dir.mkdir(parents=True, exist_ok=True)
            
            # 确定文件名
            filename = self.update_info.get('filename', 'update.exe')
            self.download_path = self.download_dir / filename
            
            logger.info(f"Downloading update from: {download_url}")
            logger.info(f"Saving to: {self.download_path}")
            
            # 下载文件
            response = requests.get(download_url, stream=True, timeout=30)
            response.raise_for_status()
            
            total_size = int(response.headers.get('content-length', 0))
            downloaded_size = 0
            
            with open(self.download_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if self.cancelled:
                        break
                        
                    if chunk:
                        f.write(chunk)
                        downloaded_size += len(chunk)
                        
                        if total_size > 0:
                            progress = int((downloaded_size / total_size) * 100)
                            self.progress_updated.emit(progress)
                            
            if self.cancelled:
                # 删除未完成的文件
                if self.download_path.exists():
                    self.download_path.unlink()
                return
                
            # 验证下载的文件
            if self._verify_download():
                logger.info("Download completed and verified")
                self.download_completed.emit(str(self.download_path))
            else:
                logger.error("Download verification failed")
                self.download_failed.emit("Downloaded file verification failed")
                
        except Exception as e:
            logger.error(f"Download failed: {e}")
            self.download_failed.emit(str(e))
            
    def _verify_download(self):
        """验证下载的文件"""
        if not self.download_path.exists():
            return False
            
        # 检查文件大小
        expected_size = self.update_info.get('file_size')
        if expected_size:
            actual_size = self.download_path.stat().st_size
            if actual_size != expected_size:
                logger.error(f"File size mismatch: expected {expected_size}, got {actual_size}")
                return False
                
        # 检查SHA256哈希
        expected_hash = self.update_info.get('sha256')
        if expected_hash:
            actual_hash = self._calculate_sha256(self.download_path)
            if actual_hash != expected_hash.lower():
                logger.error(f"Hash mismatch: expected {expected_hash}, got {actual_hash}")
                return False
                
        return True
        
    def _calculate_sha256(self, file_path):
        """计算文件SHA256哈希"""
        hash_sha256 = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_sha256.update(chunk)
        return hash_sha256.hexdigest()
        
    def cancel(self):
        """取消下载"""
        self.cancelled = True

class UpdateInstaller(QObject):
    """更新安装器"""
    
    installation_started = pyqtSignal()
    installation_completed = pyqtSignal()
    installation_failed = pyqtSignal(str)
    
    def __init__(self, update_file_path, parent=None):
        super().__init__(parent)
        self.update_file_path = Path(update_file_path)
        
    def install_update(self, silent=True):
        """安装更新"""
        try:
            if not self.update_file_path.exists():
                self.installation_failed.emit("Update file not found")
                return
                
            logger.info(f"Installing update: {self.update_file_path}")
            self.installation_started.emit()
            
            # 构建安装命令
            cmd = [str(self.update_file_path)]
            
            if silent:
                cmd.extend(['/SILENT', '/NORESTART'])
            else:
                cmd.extend(['/NORESTART'])
                
            # 执行安装
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            
            # 等待安装完成
            stdout, stderr = process.communicate(timeout=300)  # 5分钟超时
            
            if process.returncode == 0:
                logger.info("Update installed successfully")
                self.installation_completed.emit()
            else:
                error_msg = f"Installation failed with code {process.returncode}"
                if stderr:
                    error_msg += f": {stderr.decode()}"
                logger.error(error_msg)
                self.installation_failed.emit(error_msg)
                
        except subprocess.TimeoutExpired:
            logger.error("Installation timed out")
            self.installation_failed.emit("Installation timed out")
        except Exception as e:
            logger.error(f"Installation failed: {e}")
            self.installation_failed.emit(str(e))

class AutoUpdater(QObject):
    """自动更新管理器"""
    
    update_check_completed = pyqtSignal(bool)  # 是否有更新
    update_progress = pyqtSignal(int, str)     # 进度, 状态消息
    update_completed = pyqtSignal(bool)        # 更新是否成功
    
    def __init__(self, current_version, update_url, parent=None):
        super().__init__(parent)
        self.current_version = current_version
        self.update_url = update_url
        
        # 组件
        self.checker = None
        self.downloader = None
        self.installer = None
        
        # 更新配置
        self.auto_check_enabled = True
        self.auto_install_enabled = False
        self.check_interval = 24 * 3600  # 24小时
        
    def check_for_updates(self, show_no_update_message=False):
        """检查更新"""
        self.checker = UpdateChecker(self.current_version, self.update_url)
        
        # 连接信号
        self.checker.update_available.connect(self._on_update_available)
        self.checker.no_update_available.connect(
            lambda: self.update_check_completed.emit(False)
        )
        self.checker.check_failed.connect(self._on_check_failed)
        
        self.checker.check_for_updates()
        
    def _on_update_available(self, update_info):
        """发现更新处理"""
        logger.info(f"Update available: {update_info}")
        self.update_info = update_info
        self.update_check_completed.emit(True)
        
        if self.auto_install_enabled:
            self.start_update()
            
    def _on_check_failed(self, error):
        """检查失败处理"""
        logger.warning(f"Update check failed: {error}")
        self.update_check_completed.emit(False)
        
    def start_update(self):
        """开始更新过程"""
        if not hasattr(self, 'update_info'):
            logger.error("No update info available")
            return
            
        # 创建临时目录
        temp_dir = Path(tempfile.gettempdir()) / "PoE2BuildGenerator_Update"
        
        # 开始下载
        self.downloader = UpdateDownloader(self.update_info, temp_dir)
        
        # 连接信号
        self.downloader.progress_updated.connect(
            lambda p: self.update_progress.emit(p, f"下载更新中... {p}%")
        )
        self.downloader.download_completed.connect(self._on_download_completed)
        self.downloader.download_failed.connect(self._on_download_failed)
        
        self.update_progress.emit(0, "开始下载更新...")
        self.downloader.start()
        
    def _on_download_completed(self, file_path):
        """下载完成处理"""
        logger.info(f"Download completed: {file_path}")
        
        # 开始安装
        self.installer = UpdateInstaller(file_path)
        
        # 连接信号
        self.installer.installation_started.connect(
            lambda: self.update_progress.emit(90, "正在安装更新...")
        )
        self.installer.installation_completed.connect(self._on_installation_completed)
        self.installer.installation_failed.connect(self._on_installation_failed)
        
        self.installer.install_update(silent=True)
        
    def _on_download_failed(self, error):
        """下载失败处理"""
        logger.error(f"Download failed: {error}")
        self.update_completed.emit(False)
        
    def _on_installation_completed(self):
        """安装完成处理"""
        logger.info("Update installation completed")
        self.update_progress.emit(100, "更新安装完成")
        self.update_completed.emit(True)
        
        # 清理临时文件
        self._cleanup_temp_files()
        
    def _on_installation_failed(self, error):
        """安装失败处理"""
        logger.error(f"Installation failed: {error}")
        self.update_completed.emit(False)
        
        # 清理临时文件
        self._cleanup_temp_files()
        
    def _cleanup_temp_files(self):
        """清理临时文件"""
        try:
            temp_dir = Path(tempfile.gettempdir()) / "PoE2BuildGenerator_Update"
            if temp_dir.exists():
                import shutil
                shutil.rmtree(temp_dir)
                logger.info("Temporary update files cleaned up")
        except Exception as e:
            logger.warning(f"Failed to cleanup temp files: {e}")
```

请确保打包分发系统实现：
1. 完整的PyInstaller配置和优化
2. 专业的Inno Setup安装程序
3. 可靠的代码签名机制
4. 智能的自动更新系统
5. 全面的兼容性测试
6. 自动化的CI/CD流水线

打包系统应该生成易于分发和安装的Windows应用程序，提供良好的用户体验和系统集成。