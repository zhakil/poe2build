请实现PoE2智能构筑生成器的Windows系统特有功能集成：

## 22.1 系统集成架构设计

### Windows功能集成层次
```
┌─── Windows Integration Layer ──────────────────────────────────────┐
│  ┌─ System Tray ───────┐  ┌─ File Association ─┐  ┌─ Registry ────┐ │
│  │ • 托盘图标           │  │ • .poe2build文件   │  │ • 配置存储    │ │
│  │ • 右键菜单          │  │ • 上下文菜单       │  │ • 启动设置    │ │
│  │ • 通知集成          │  │ • 拖放支持         │  │ • 关联设置    │ │
│  └─────────────────────┘  └───────────────────┘  └───────────────┘ │
└───────────────────────────────────────────────────────────────────┘
┌─── Windows Native Services ────────────────────────────────────────┐
│  ┌─ Notification System ─┐  ┌─ Task Scheduler ──┐  ┌─ Shell Ext ──┐ │
│  │ • Toast通知           │  │ • 自动更新任务     │  │ • 缩略图生成  │ │
│  │ • 通知中心集成        │  │ • 清理任务         │  │ • 预览支持    │ │
│  │ • 操作按钮           │  │ • 数据同步         │  │ • 属性扩展    │ │
│  └───────────────────────┘  └───────────────────┘  └──────────────┘ │
└───────────────────────────────────────────────────────────────────┘
┌─── Windows Security & Performance ──────────────────────────────────┐
│  ┌─ UAC Integration ──┐  ┌─ Performance ────┐  ┌─ Security ────────┐ │
│  │ • 管理员权限检测    │  │ • CPU使用优化     │  │ • 数字签名验证     │ │
│  │ • 权限请求处理      │  │ • 内存管理        │  │ • 数据加密存储     │ │
│  │ • 安全操作          │  │ • 后台优先级      │  │ • 安全通信        │ │
│  └────────────────────┘  └──────────────────┘  └───────────────────┘ │
└───────────────────────────────────────────────────────────────────┘
```

### 核心Windows服务类
```python
class WindowsIntegrationManager(QObject):
    """Windows系统集成管理器"""
    
    # 系统信号
    tray_activated = pyqtSignal(str)           # 托盘激活
    file_association_changed = pyqtSignal(bool) # 文件关联状态
    notification_clicked = pyqtSignal(dict)    # 系统通知点击
    registry_updated = pyqtSignal(str, object) # 注册表更新
    
    def __init__(self, main_window, parent=None):
        super().__init__(parent)
        self.main_window = main_window
        
        # Windows功能组件
        self.system_tray = None
        self.file_associator = None
        self.registry_manager = None
        self.notification_manager = None
        self.task_scheduler = None
        
        # 初始化Windows功能
        self._initialize_windows_features()
        
    def _initialize_windows_features(self):
        """初始化Windows功能"""
        try:
            # 检查系统托盘支持
            if QSystemTrayIcon.isSystemTrayAvailable():
                self.system_tray = WindowsSystemTray(self.main_window, self)
                
            # 初始化文件关联管理器
            self.file_associator = FileAssociationManager(self)
            
            # 初始化注册表管理器
            self.registry_manager = WindowsRegistryManager(self)
            
            # 初始化Windows通知管理器
            self.notification_manager = WindowsNotificationManager(self)
            
            # 初始化任务调度器
            self.task_scheduler = WindowsTaskScheduler(self)
            
            logger.info("Windows integration features initialized successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize Windows features: {e}")
            
    def setup_system_integration(self):
        """设置系统集成"""
        # 设置文件关联
        self._setup_file_associations()
        
        # 配置系统托盘
        self._setup_system_tray()
        
        # 注册Windows通知
        self._setup_notifications()
        
        # 配置启动选项
        self._setup_startup_options()
        
    def _setup_file_associations(self):
        """设置文件关联"""
        if self.file_associator:
            # 检查当前关联状态
            is_associated = self.file_associator.is_associated(".poe2build")
            
            if not is_associated:
                # 询问用户是否要关联文件类型
                reply = QMessageBox.question(
                    self.main_window,
                    "文件关联",
                    "是否要将.poe2build文件与本应用关联？\n这将允许双击.poe2build文件直接打开构筑。",
                    QMessageBox.Yes | QMessageBox.No
                )
                
                if reply == QMessageBox.Yes:
                    try:
                        self.file_associator.associate_file_type(
                            ".poe2build", 
                            "PoE2 Build File",
                            "PoE2构筑文件"
                        )
                        
                        QMessageBox.information(
                            self.main_window,
                            "文件关联",
                            "文件关联设置成功！"
                        )
                    except Exception as e:
                        QMessageBox.warning(
                            self.main_window,
                            "文件关联失败", 
                            f"设置文件关联时出错：{e}"
                        )
                        
    def _setup_system_tray(self):
        """设置系统托盘"""
        if self.system_tray:
            self.system_tray.setup_tray_icon()
            self.system_tray.setup_context_menu()
            
            # 连接托盘信号
            self.system_tray.activated.connect(self._on_tray_activated)
            self.system_tray.message_clicked.connect(self._on_tray_message_clicked)
            
    def _on_tray_activated(self, reason):
        """托盘图标激活处理"""
        if reason == QSystemTrayIcon.DoubleClick:
            # 双击显示/隐藏主窗口
            if self.main_window.isVisible():
                self.main_window.hide()
            else:
                self.main_window.show()
                self.main_window.raise_()
                self.main_window.activateWindow()
        elif reason == QSystemTrayIcon.MiddleClick:
            # 中键点击快速生成构筑
            self._quick_generate_build()
            
    def _quick_generate_build(self):
        """快速生成构筑"""
        # 使用默认设置快速生成构筑
        quick_settings = {
            'selected_class': 'Witch',
            'build_goal': 'balanced',
            'budget_amount': 10,
            'budget_currency': 'Divine Orb'
        }
        
        # 触发快速生成
        self.main_window._quick_generate_from_settings(quick_settings)
```

## 22.2 系统托盘集成

### WindowsSystemTray 实现
```python
class WindowsSystemTray(QObject):
    """Windows系统托盘集成"""
    
    activated = pyqtSignal(int)
    message_clicked = pyqtSignal()
    
    def __init__(self, main_window, parent=None):
        super().__init__(parent)
        self.main_window = main_window
        self.tray_icon = None
        self.context_menu = None
        
        # 托盘状态
        self.last_notification_time = 0
        self.notification_count = 0
        
    def setup_tray_icon(self):
        """设置托盘图标"""
        if not QSystemTrayIcon.isSystemTrayAvailable():
            QMessageBox.critical(
                self.main_window,
                "系统托盘",
                "系统托盘不可用，某些功能可能无法正常工作。"
            )
            return
            
        self.tray_icon = QSystemTrayIcon(self)
        
        # 设置图标
        self._update_tray_icon("normal")
        
        # 设置工具提示
        self.tray_icon.setToolTip("PoE2智能构筑生成器")
        
        # 连接信号
        self.tray_icon.activated.connect(self.activated)
        self.tray_icon.messageClicked.connect(self.message_clicked)
        
        # 显示托盘图标
        self.tray_icon.show()
        
    def setup_context_menu(self):
        """设置右键上下文菜单"""
        self.context_menu = QMenu()
        
        # 菜单样式
        self.context_menu.setStyleSheet("""
        QMenu {
            background-color: #2a2a2a;
            color: #f0f0f0;
            border: 2px solid #444444;
            border-radius: 6px;
            padding: 4px;
        }
        QMenu::item {
            background-color: transparent;
            padding: 8px 20px;
            border-radius: 4px;
        }
        QMenu::item:selected {
            background-color: #c9aa71;
            color: #0a0a0a;
        }
        QMenu::separator {
            height: 1px;
            background-color: #444444;
            margin: 4px 0;
        }
        """)
        
        # 显示/隐藏主窗口
        show_action = QAction("显示主窗口", self)
        show_action.triggered.connect(self._show_main_window)
        self.context_menu.addAction(show_action)
        
        hide_action = QAction("隐藏到托盘", self) 
        hide_action.triggered.connect(self._hide_main_window)
        self.context_menu.addAction(hide_action)
        
        self.context_menu.addSeparator()
        
        # 快速操作
        quick_generate_action = QAction("快速生成构筑", self)
        quick_generate_action.triggered.connect(self._quick_generate)
        self.context_menu.addAction(quick_generate_action)
        
        open_recent_action = QAction("打开最近构筑", self)
        open_recent_action.triggered.connect(self._open_recent_build)
        self.context_menu.addAction(open_recent_action)
        
        self.context_menu.addSeparator()
        
        # 系统状态
        system_status_action = QAction("系统状态", self)
        system_status_action.triggered.connect(self._show_system_status)
        self.context_menu.addAction(system_status_action)
        
        # 设置
        settings_action = QAction("设置", self)
        settings_action.triggered.connect(self._show_settings)
        self.context_menu.addAction(settings_action)
        
        self.context_menu.addSeparator()
        
        # 退出
        quit_action = QAction("退出", self)
        quit_action.triggered.connect(self._quit_application)
        self.context_menu.addAction(quit_action)
        
        # 设置上下文菜单
        self.tray_icon.setContextMenu(self.context_menu)
        
    def _update_tray_icon(self, status):
        """更新托盘图标"""
        icon_files = {
            "normal": "resources/icons/tray_normal.ico",
            "working": "resources/icons/tray_working.ico", 
            "error": "resources/icons/tray_error.ico",
            "notification": "resources/icons/tray_notification.ico"
        }
        
        icon_file = icon_files.get(status, icon_files["normal"])
        
        if os.path.exists(icon_file):
            self.tray_icon.setIcon(QIcon(icon_file))
        else:
            # 使用默认应用图标
            self.tray_icon.setIcon(self.main_window.windowIcon())
            
    def show_tray_message(self, title, message, icon_type="info", duration=3000):
        """显示托盘消息"""
        if not self.tray_icon:
            return
            
        # 防止消息过于频繁
        current_time = time.time()
        if current_time - self.last_notification_time < 2:  # 2秒内不重复显示
            return
            
        self.last_notification_time = current_time
        self.notification_count += 1
        
        # 图标类型映射
        icon_mapping = {
            "info": QSystemTrayIcon.Information,
            "warning": QSystemTrayIcon.Warning,
            "error": QSystemTrayIcon.Critical,
            "none": QSystemTrayIcon.NoIcon
        }
        
        icon = icon_mapping.get(icon_type, QSystemTrayIcon.Information)
        
        # 显示托盘消息
        self.tray_icon.showMessage(title, message, icon, duration)
        
        # 更新托盘图标状态
        if icon_type == "error":
            self._update_tray_icon("error")
        elif icon_type == "working":
            self._update_tray_icon("working")
        else:
            self._update_tray_icon("notification")
            
        # 延迟恢复正常图标
        QTimer.singleShot(duration, lambda: self._update_tray_icon("normal"))
        
    def _show_main_window(self):
        """显示主窗口"""
        self.main_window.show()
        self.main_window.raise_()
        self.main_window.activateWindow()
        
        # 如果窗口被最小化，恢复正常状态
        if self.main_window.isMinimized():
            self.main_window.showNormal()
            
    def _hide_main_window(self):
        """隐藏主窗口到托盘"""
        self.main_window.hide()
        
        # 首次隐藏时显示提示
        if not hasattr(self, '_hide_tip_shown'):
            self.show_tray_message(
                "PoE2构筑生成器",
                "应用已最小化到系统托盘。双击托盘图标可重新显示窗口。",
                "info"
            )
            self._hide_tip_shown = True
            
    def _quick_generate(self):
        """快速生成构筑"""
        # 显示进度通知
        self.show_tray_message(
            "构筑生成",
            "正在使用默认设置快速生成构筑...",
            "info"
        )
        
        # 更新图标状态
        self._update_tray_icon("working")
        
        # 调用主窗口的快速生成功能
        if hasattr(self.main_window, '_quick_generate_default'):
            self.main_window._quick_generate_default()
            
    def _open_recent_build(self):
        """打开最近构筑"""
        # 获取最近构筑列表
        recent_builds = self.main_window.settings_manager.get("recent_builds", [])
        
        if not recent_builds:
            self.show_tray_message(
                "最近构筑",
                "没有找到最近的构筑文件。",
                "info"
            )
            return
            
        # 打开最近的构筑
        latest_build = recent_builds[0]
        self.main_window._load_build_file(latest_build)
        
        # 显示主窗口
        self._show_main_window()
        
    def _show_system_status(self):
        """显示系统状态"""
        self._show_main_window()
        self.main_window._switch_page("status")
        
    def _show_settings(self):
        """显示设置"""
        self._show_main_window()
        self.main_window._switch_page("settings")
        
    def _quit_application(self):
        """退出应用程序"""
        # 确认退出
        reply = QMessageBox.question(
            None,
            "确认退出",
            "确定要退出PoE2智能构筑生成器吗？",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # 隐藏托盘图标
            if self.tray_icon:
                self.tray_icon.hide()
                
            # 退出应用
            QApplication.instance().quit()
```

## 22.3 文件关联系统

### FileAssociationManager 实现
```python
class FileAssociationManager(QObject):
    """文件关联管理器"""
    
    association_changed = pyqtSignal(str, bool)  # 文件扩展名, 关联状态
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.app_path = QApplication.applicationFilePath()
        self.app_dir = QApplication.applicationDirPath()
        
    def associate_file_type(self, extension, file_type_name, description):
        """关联文件类型"""
        try:
            import winreg
            
            # 确保扩展名以点开头
            if not extension.startswith('.'):
                extension = '.' + extension
                
            # 注册文件扩展名
            ext_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, f"Software\\Classes\\{extension}")
            winreg.SetValueEx(ext_key, "", 0, winreg.REG_SZ, file_type_name)
            winreg.CloseKey(ext_key)
            
            # 注册文件类型
            type_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, f"Software\\Classes\\{file_type_name}")
            winreg.SetValueEx(type_key, "", 0, winreg.REG_SZ, description)
            winreg.CloseKey(type_key)
            
            # 设置默认图标
            icon_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, 
                                       f"Software\\Classes\\{file_type_name}\\DefaultIcon")
            icon_path = f'"{self.app_path}",0'
            winreg.SetValueEx(icon_key, "", 0, winreg.REG_SZ, icon_path)
            winreg.CloseKey(icon_key)
            
            # 设置打开命令
            command_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER,
                                         f"Software\\Classes\\{file_type_name}\\shell\\open\\command")
            command_value = f'"{self.app_path}" "%1"'
            winreg.SetValueEx(command_key, "", 0, winreg.REG_SZ, command_value)
            winreg.CloseKey(command_key)
            
            # 设置右键菜单项
            self._setup_context_menu(file_type_name)
            
            # 通知系统更新文件关联
            self._notify_shell_change()
            
            logger.info(f"File association created for {extension} -> {file_type_name}")
            self.association_changed.emit(extension, True)
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to associate file type: {e}")
            return False
            
    def _setup_context_menu(self, file_type_name):
        """设置右键上下文菜单"""
        try:
            import winreg
            
            # 添加"编辑构筑"菜单项
            edit_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER,
                                       f"Software\\Classes\\{file_type_name}\\shell\\edit")
            winreg.SetValueEx(edit_key, "", 0, winreg.REG_SZ, "编辑构筑(&E)")
            winreg.SetValueEx(edit_key, "Icon", 0, winreg.REG_SZ, f'"{self.app_path}",0')
            winreg.CloseKey(edit_key)
            
            edit_command_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER,
                                              f"Software\\Classes\\{file_type_name}\\shell\\edit\\command")
            edit_command = f'"{self.app_path}" --edit "%1"'
            winreg.SetValueEx(edit_command_key, "", 0, winreg.REG_SZ, edit_command)
            winreg.CloseKey(edit_command_key)
            
            # 添加"导出到PoB"菜单项
            export_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER,
                                        f"Software\\Classes\\{file_type_name}\\shell\\export_pob")
            winreg.SetValueEx(export_key, "", 0, winreg.REG_SZ, "导出到PoB(&P)")
            winreg.CloseKey(export_key)
            
            export_command_key = winreg.CreateKey(winreg.HKEY_CURRENT_USER,
                                                f"Software\\Classes\\{file_type_name}\\shell\\export_pob\\command")
            export_command = f'"{self.app_path}" --export-pob "%1"'
            winreg.SetValueEx(export_command_key, "", 0, winreg.REG_SZ, export_command)
            winreg.CloseKey(export_command_key)
            
        except Exception as e:
            logger.warning(f"Failed to setup context menu: {e}")
            
    def _notify_shell_change(self):
        """通知Shell文件关联已更改"""
        try:
            import ctypes
            from ctypes import wintypes
            
            # 调用SHChangeNotify通知Shell
            ctypes.windll.shell32.SHChangeNotify(
                0x08000000,  # SHCNE_ASSOCCHANGED
                0x0000,      # SHCNF_IDLIST
                None, None
            )
        except:
            pass  # 忽略错误，不影响功能
            
    def is_associated(self, extension):
        """检查文件是否已关联"""
        try:
            import winreg
            
            if not extension.startswith('.'):
                extension = '.' + extension
                
            # 检查注册表项
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, f"Software\\Classes\\{extension}")
            file_type = winreg.QueryValueEx(key, "")[0]
            winreg.CloseKey(key)
            
            # 检查命令是否指向当前应用
            command_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER,
                                       f"Software\\Classes\\{file_type}\\shell\\open\\command")
            command = winreg.QueryValueEx(command_key, "")[0]
            winreg.CloseKey(command_key)
            
            return self.app_path in command
            
        except:
            return False
            
    def remove_association(self, extension):
        """移除文件关联"""
        try:
            import winreg
            
            if not extension.startswith('.'):
                extension = '.' + extension
                
            # 获取文件类型名
            ext_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, f"Software\\Classes\\{extension}")
            file_type_name = winreg.QueryValueEx(ext_key, "")[0]
            winreg.CloseKey(ext_key)
            
            # 删除文件类型注册
            winreg.DeleteKeyEx(winreg.HKEY_CURRENT_USER, f"Software\\Classes\\{file_type_name}")
            
            # 删除扩展名注册
            winreg.DeleteKeyEx(winreg.HKEY_CURRENT_USER, f"Software\\Classes\\{extension}")
            
            # 通知系统
            self._notify_shell_change()
            
            logger.info(f"File association removed for {extension}")
            self.association_changed.emit(extension, False)
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to remove file association: {e}")
            return False
            
    def handle_file_open(self, file_path):
        """处理文件打开请求"""
        try:
            # 验证文件存在且为支持的格式
            if not os.path.exists(file_path):
                QMessageBox.warning(
                    None, "文件不存在",
                    f"指定的文件不存在：\n{file_path}"
                )
                return False
                
            if not file_path.lower().endswith('.poe2build'):
                QMessageBox.warning(
                    None, "不支持的文件格式",
                    f"不支持的文件格式：{os.path.splitext(file_path)[1]}"
                )
                return False
                
            # 获取主窗口实例
            app = QApplication.instance()
            main_window = None
            
            for widget in app.topLevelWidgets():
                if isinstance(widget, QMainWindow) and hasattr(widget, '_load_build_file'):
                    main_window = widget
                    break
                    
            if main_window:
                # 显示主窗口
                main_window.show()
                main_window.raise_()
                main_window.activateWindow()
                
                # 加载构筑文件
                main_window._load_build_file(file_path)
                return True
            else:
                QMessageBox.warning(
                    None, "应用程序错误",
                    "无法找到主窗口实例。"
                )
                return False
                
        except Exception as e:
            QMessageBox.critical(
                None, "文件打开错误",
                f"打开文件时发生错误：\n{e}"
            )
            return False
```

## 22.4 Windows通知系统

### WindowsNotificationManager 实现
```python
class WindowsNotificationManager(QObject):
    """Windows通知管理器"""
    
    notification_clicked = pyqtSignal(dict)
    notification_dismissed = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # 检查Windows版本和通知支持
        self.windows_version = self._get_windows_version()
        self.toast_supported = self._check_toast_support()
        
        # 通知历史
        self.notification_history = []
        self.active_notifications = {}
        
    def _get_windows_version(self):
        """获取Windows版本"""
        try:
            import platform
            version = platform.version()
            return version
        except:
            return "Unknown"
            
    def _check_toast_support(self):
        """检查Toast通知支持"""
        try:
            # 检查是否为Windows 10或更高版本
            import platform
            version_info = platform.version().split('.')
            major_version = int(version_info[0])
            
            return major_version >= 10
        except:
            return False
            
    def show_toast_notification(self, title, message, icon="info", duration=5000, 
                              actions=None, data=None):
        """显示Toast通知"""
        if not self.toast_supported:
            # 回退到系统托盘通知
            return self._show_tray_notification(title, message, icon, duration)
            
        try:
            # 创建Windows Toast通知
            notification_id = str(uuid.uuid4())
            
            # 准备通知数据
            notification_data = {
                'id': notification_id,
                'title': title,
                'message': message,
                'icon': icon,
                'timestamp': time.time(),
                'data': data or {}
            }
            
            # 使用win10toast库显示通知（需要安装：pip install win10toast）
            try:
                from win10toast import ToastNotifier
                
                toaster = ToastNotifier()
                
                # 设置图标路径
                icon_path = None
                if icon == "info":
                    icon_path = "resources/icons/notification_info.ico"
                elif icon == "success":
                    icon_path = "resources/icons/notification_success.ico"
                elif icon == "warning":
                    icon_path = "resources/icons/notification_warning.ico"
                elif icon == "error":
                    icon_path = "resources/icons/notification_error.ico"
                    
                # 显示通知
                toaster.show_toast(
                    title=title,
                    msg=message,
                    icon_path=icon_path,
                    duration=duration // 1000,  # 转换为秒
                    threaded=True,
                    callback_on_click=lambda: self._on_toast_clicked(notification_data)
                )
                
                # 记录活跃通知
                self.active_notifications[notification_id] = notification_data
                
                # 添加到历史记录
                self.notification_history.append(notification_data)
                
                logger.info(f"Toast notification shown: {title}")
                return notification_id
                
            except ImportError:
                logger.warning("win10toast not available, falling back to system tray")
                return self._show_tray_notification(title, message, icon, duration)
                
        except Exception as e:
            logger.error(f"Failed to show toast notification: {e}")
            return None
            
    def _show_tray_notification(self, title, message, icon, duration):
        """显示系统托盘通知（备用方案）"""
        try:
            # 获取系统托盘实例
            app = QApplication.instance()
            for widget in app.topLevelWidgets():
                if hasattr(widget, 'windows_integration_manager'):
                    tray = widget.windows_integration_manager.system_tray
                    if tray:
                        tray.show_tray_message(title, message, icon, duration)
                        return "tray_notification"
                    break
        except:
            pass
            
        return None
        
    def _on_toast_clicked(self, notification_data):
        """Toast通知点击处理"""
        try:
            notification_id = notification_data['id']
            
            # 发射点击信号
            self.notification_clicked.emit(notification_data)
            
            # 从活跃通知中移除
            self.active_notifications.pop(notification_id, None)
            
            logger.info(f"Toast notification clicked: {notification_data['title']}")
            
        except Exception as e:
            logger.error(f"Error handling toast click: {e}")
            
    def show_progress_notification(self, title, current, total, message=""):
        """显示进度通知"""
        try:
            percentage = int((current / total) * 100) if total > 0 else 0
            
            progress_message = f"{message}\n进度: {current}/{total} ({percentage}%)"
            
            return self.show_toast_notification(
                title=title,
                message=progress_message,
                icon="info",
                duration=2000,
                data={'type': 'progress', 'current': current, 'total': total}
            )
            
        except Exception as e:
            logger.error(f"Failed to show progress notification: {e}")
            return None
            
    def show_build_completion_notification(self, build_data):
        """显示构筑完成通知"""
        try:
            title = "构筑生成完成"
            message = f"已生成 {len(build_data.get('recommendations', []))} 个构筑推荐"
            
            # 添加操作按钮（如果支持）
            actions = [
                {"action": "view", "title": "查看结果"},
                {"action": "export", "title": "导出PoB"}
            ]
            
            return self.show_toast_notification(
                title=title,
                message=message,
                icon="success",
                duration=8000,
                actions=actions,
                data={'type': 'build_completion', 'build_data': build_data}
            )
            
        except Exception as e:
            logger.error(f"Failed to show build completion notification: {e}")
            return None
            
    def clear_all_notifications(self):
        """清除所有通知"""
        try:
            # 清除活跃通知
            self.active_notifications.clear()
            
            # 清除通知历史（保留最近50条）
            if len(self.notification_history) > 50:
                self.notification_history = self.notification_history[-50:]
                
            logger.info("All notifications cleared")
            
        except Exception as e:
            logger.error(f"Failed to clear notifications: {e}")
            
    def get_notification_history(self, limit=20):
        """获取通知历史"""
        return self.notification_history[-limit:] if self.notification_history else []
```

## 22.5 注册表管理

### WindowsRegistryManager 实现
```python
class WindowsRegistryManager(QObject):
    """Windows注册表管理器"""
    
    registry_changed = pyqtSignal(str, str, object)  # 键路径, 值名, 新值
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.app_name = "PoE2BuildGenerator"
        self.base_key_path = f"Software\\{self.app_name}"
        
    def set_value(self, key_path, value_name, value, value_type="string"):
        """设置注册表值"""
        try:
            import winreg
            
            full_key_path = f"{self.base_key_path}\\{key_path}" if key_path else self.base_key_path
            
            # 创建或打开键
            key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, full_key_path)
            
            # 根据类型设置值
            if value_type == "string":
                winreg.SetValueEx(key, value_name, 0, winreg.REG_SZ, str(value))
            elif value_type == "dword":
                winreg.SetValueEx(key, value_name, 0, winreg.REG_DWORD, int(value))
            elif value_type == "binary":
                winreg.SetValueEx(key, value_name, 0, winreg.REG_BINARY, value)
            
            winreg.CloseKey(key)
            
            # 发射变更信号
            self.registry_changed.emit(full_key_path, value_name, value)
            
            logger.debug(f"Registry value set: {full_key_path}\\{value_name} = {value}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to set registry value: {e}")
            return False
            
    def get_value(self, key_path, value_name, default_value=None):
        """获取注册表值"""
        try:
            import winreg
            
            full_key_path = f"{self.base_key_path}\\{key_path}" if key_path else self.base_key_path
            
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, full_key_path)
            value, _ = winreg.QueryValueEx(key, value_name)
            winreg.CloseKey(key)
            
            return value
            
        except:
            return default_value
            
    def delete_value(self, key_path, value_name):
        """删除注册表值"""
        try:
            import winreg
            
            full_key_path = f"{self.base_key_path}\\{key_path}" if key_path else self.base_key_path
            
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, full_key_path, 0, winreg.KEY_WRITE)
            winreg.DeleteValue(key, value_name)
            winreg.CloseKey(key)
            
            logger.debug(f"Registry value deleted: {full_key_path}\\{value_name}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to delete registry value: {e}")
            return False
            
    def setup_startup_entry(self, enable=True):
        """设置开机启动项"""
        startup_key_path = "Software\\Microsoft\\Windows\\CurrentVersion\\Run"
        app_name = "PoE2BuildGenerator"
        
        try:
            import winreg
            
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, startup_key_path, 0, winreg.KEY_WRITE)
            
            if enable:
                app_path = QApplication.applicationFilePath()
                startup_command = f'"{app_path}" --startup'
                winreg.SetValueEx(key, app_name, 0, winreg.REG_SZ, startup_command)
                logger.info("Startup entry created")
            else:
                try:
                    winreg.DeleteValue(key, app_name)
                    logger.info("Startup entry removed")
                except FileNotFoundError:
                    pass  # 值不存在，忽略
                    
            winreg.CloseKey(key)
            return True
            
        except Exception as e:
            logger.error(f"Failed to setup startup entry: {e}")
            return False
            
    def is_startup_enabled(self):
        """检查是否设置了开机启动"""
        startup_key_path = "Software\\Microsoft\\Windows\\CurrentVersion\\Run"
        app_name = "PoE2BuildGenerator"
        
        try:
            import winreg
            
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, startup_key_path)
            value, _ = winreg.QueryValueEx(key, app_name)
            winreg.CloseKey(key)
            
            return True
            
        except:
            return False
            
    def store_window_geometry(self, geometry_data):
        """存储窗口几何信息"""
        try:
            # 将QByteArray转换为hex字符串存储
            hex_data = geometry_data.toHex().data().decode('ascii')
            return self.set_value("UI", "WindowGeometry", hex_data)
        except Exception as e:
            logger.error(f"Failed to store window geometry: {e}")
            return False
            
    def restore_window_geometry(self):
        """恢复窗口几何信息"""
        try:
            hex_data = self.get_value("UI", "WindowGeometry")
            if hex_data:
                # 将hex字符串转换回QByteArray
                geometry_data = QByteArray.fromHex(hex_data.encode('ascii'))
                return geometry_data
            return None
        except Exception as e:
            logger.error(f"Failed to restore window geometry: {e}")
            return None
            
    def store_user_preferences(self, preferences):
        """存储用户偏好设置"""
        try:
            import json
            
            # 将偏好设置转换为JSON字符串存储
            json_data = json.dumps(preferences, ensure_ascii=False)
            return self.set_value("Settings", "UserPreferences", json_data)
        except Exception as e:
            logger.error(f"Failed to store user preferences: {e}")
            return False
            
    def restore_user_preferences(self):
        """恢复用户偏好设置"""
        try:
            import json
            
            json_data = self.get_value("Settings", "UserPreferences")
            if json_data:
                return json.loads(json_data)
            return {}
        except Exception as e:
            logger.error(f"Failed to restore user preferences: {e}")
            return {}
            
    def cleanup_registry_entries(self):
        """清理注册表项"""
        try:
            import winreg
            
            # 递归删除应用的注册表项
            def delete_key_recursive(key, subkey_path):
                try:
                    subkey = winreg.OpenKey(key, subkey_path)
                    
                    # 获取所有子键
                    subkey_names = []
                    i = 0
                    while True:
                        try:
                            subkey_names.append(winreg.EnumKey(subkey, i))
                            i += 1
                        except WindowsError:
                            break
                            
                    # 递归删除子键
                    for name in subkey_names:
                        delete_key_recursive(subkey, name)
                        
                    winreg.CloseKey(subkey)
                    winreg.DeleteKey(key, subkey_path)
                    
                except Exception as e:
                    logger.warning(f"Failed to delete registry key {subkey_path}: {e}")
                    
            # 删除应用的主注册表项
            delete_key_recursive(winreg.HKEY_CURRENT_USER, self.base_key_path)
            
            logger.info("Registry entries cleaned up")
            return True
            
        except Exception as e:
            logger.error(f"Failed to cleanup registry entries: {e}")
            return False
```

## 22.6 自动更新和任务调度

### WindowsTaskScheduler 实现
```python
class WindowsTaskScheduler(QObject):
    """Windows任务调度器"""
    
    task_completed = pyqtSignal(str, bool)  # 任务名, 成功状态
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.scheduled_tasks = {}
        
    def schedule_data_update_task(self):
        """调度数据更新任务"""
        try:
            # 创建每日数据更新任务
            task_name = "PoE2BuildGenerator_DataUpdate"
            
            # 使用Windows任务计划程序
            app_path = QApplication.applicationFilePath()
            update_command = f'"{app_path}" --update-data --silent'
            
            # 创建批处理文件
            batch_file = os.path.join(QApplication.applicationDirPath(), "update_data.bat")
            with open(batch_file, 'w', encoding='utf-8') as f:
                f.write(f'@echo off\n')
                f.write(f'{update_command}\n')
                f.write(f'exit /b %errorlevel%\n')
                
            # 使用schtasks命令创建任务
            import subprocess
            
            schtasks_command = [
                'schtasks', '/create',
                '/tn', task_name,
                '/tr', batch_file,
                '/sc', 'daily',
                '/st', '02:00',  # 凌晨2点执行
                '/f'  # 强制创建，覆盖已存在的任务
            ]
            
            result = subprocess.run(schtasks_command, capture_output=True, text=True)
            
            if result.returncode == 0:
                logger.info(f"Scheduled task created: {task_name}")
                self.scheduled_tasks[task_name] = {
                    'type': 'data_update',
                    'command': update_command,
                    'schedule': 'daily',
                    'time': '02:00'
                }
                return True
            else:
                logger.error(f"Failed to create scheduled task: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"Failed to schedule data update task: {e}")
            return False
            
    def schedule_cache_cleanup_task(self):
        """调度缓存清理任务"""
        try:
            task_name = "PoE2BuildGenerator_CacheCleanup"
            
            app_path = QApplication.applicationFilePath()
            cleanup_command = f'"{app_path}" --cleanup-cache --silent'
            
            # 创建批处理文件
            batch_file = os.path.join(QApplication.applicationDirPath(), "cleanup_cache.bat")
            with open(batch_file, 'w', encoding='utf-8') as f:
                f.write(f'@echo off\n')
                f.write(f'{cleanup_command}\n')
                f.write(f'exit /b %errorlevel%\n')
                
            # 创建周任务
            import subprocess
            
            schtasks_command = [
                'schtasks', '/create',
                '/tn', task_name,
                '/tr', batch_file,
                '/sc', 'weekly',
                '/d', 'SUN',  # 每周日
                '/st', '03:00',  # 凌晨3点执行
                '/f'
            ]
            
            result = subprocess.run(schtasks_command, capture_output=True, text=True)
            
            if result.returncode == 0:
                logger.info(f"Scheduled task created: {task_name}")
                self.scheduled_tasks[task_name] = {
                    'type': 'cache_cleanup',
                    'command': cleanup_command,
                    'schedule': 'weekly',
                    'day': 'sunday',
                    'time': '03:00'
                }
                return True
            else:
                logger.error(f"Failed to create scheduled task: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"Failed to schedule cache cleanup task: {e}")
            return False
            
    def remove_scheduled_task(self, task_name):
        """移除调度任务"""
        try:
            import subprocess
            
            schtasks_command = ['schtasks', '/delete', '/tn', task_name, '/f']
            result = subprocess.run(schtasks_command, capture_output=True, text=True)
            
            if result.returncode == 0:
                logger.info(f"Scheduled task removed: {task_name}")
                self.scheduled_tasks.pop(task_name, None)
                return True
            else:
                logger.warning(f"Failed to remove scheduled task: {result.stderr}")
                return False
                
        except Exception as e:
            logger.error(f"Failed to remove scheduled task: {e}")
            return False
            
    def remove_all_scheduled_tasks(self):
        """移除所有调度任务"""
        tasks_to_remove = [
            "PoE2BuildGenerator_DataUpdate",
            "PoE2BuildGenerator_CacheCleanup"
        ]
        
        success_count = 0
        for task_name in tasks_to_remove:
            if self.remove_scheduled_task(task_name):
                success_count += 1
                
        return success_count == len(tasks_to_remove)
        
    def get_scheduled_tasks_status(self):
        """获取调度任务状态"""
        try:
            import subprocess
            
            status = {}
            
            for task_name in self.scheduled_tasks.keys():
                schtasks_command = ['schtasks', '/query', '/tn', task_name]
                result = subprocess.run(schtasks_command, capture_output=True, text=True)
                
                if result.returncode == 0:
                    status[task_name] = {
                        'exists': True,
                        'last_run': self._parse_last_run_time(result.stdout),
                        'next_run': self._parse_next_run_time(result.stdout),
                        'status': self._parse_task_status(result.stdout)
                    }
                else:
                    status[task_name] = {'exists': False}
                    
            return status
            
        except Exception as e:
            logger.error(f"Failed to get scheduled tasks status: {e}")
            return {}
            
    def _parse_last_run_time(self, output):
        """解析最后运行时间"""
        # 简化实现，实际应该解析schtasks输出
        return "N/A"
        
    def _parse_next_run_time(self, output):
        """解析下次运行时间"""
        # 简化实现，实际应该解析schtasks输出
        return "N/A"
        
    def _parse_task_status(self, output):
        """解析任务状态"""
        # 简化实现，实际应该解析schtasks输出
        return "Ready"
```

请确保Windows功能集成实现：
1. 完整的系统托盘功能和右键菜单
2. 可靠的文件关联和Shell集成
3. 现代化的Windows通知系统
4. 安全的注册表管理
5. 自动化的任务调度功能
6. 符合Windows应用设计标准

所有Windows特性都应该优雅地降级，确保在不支持某些功能的系统上也能正常工作。