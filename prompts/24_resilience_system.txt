请实现PoE2智能构筑生成器的弹性系统架构：

## 24.1 弹性架构设计

### 核心弹性组件
```
src/poe2build/resilience/
├── __init__.py
├── circuit_breaker.py          # 断路器模式
├── rate_limiter.py             # 速率限制器  
├── retry_handler.py            # 重试处理器
├── cache_manager.py            # 缓存管理器
└── fallback_provider.py       # 降级服务提供者
```

## 24.2 断路器实现

### 断路器模式
```python
# src/poe2build/resilience/circuit_breaker.py

import time
import threading
from enum import Enum
from typing import Callable, Any, Optional
from dataclasses import dataclass, field

class CircuitBreakerState(Enum):
    CLOSED = "closed"      # 正常状态，允许请求通过
    OPEN = "open"          # 断开状态，拒绝所有请求
    HALF_OPEN = "half_open"  # 半开状态，允许部分请求测试服务

@dataclass
class CircuitBreakerConfig:
    failure_threshold: int = 5           # 失败阈值
    recovery_timeout: float = 60.0       # 恢复超时时间(秒)
    expected_exception: type = Exception # 预期的异常类型
    fallback_function: Optional[Callable] = None

class CircuitBreaker:
    """断路器实现 - 防止级联故障"""
    
    def __init__(self, config: CircuitBreakerConfig):
        self.config = config
        self.failure_count = 0
        self.last_failure_time = None
        self.state = CircuitBreakerState.CLOSED
        self._lock = threading.RLock()
        
    def call(self, func: Callable, *args, **kwargs) -> Any:
        """执行被保护的函数调用"""
        with self._lock:
            if self.state == CircuitBreakerState.OPEN:
                if self._should_attempt_reset():
                    self.state = CircuitBreakerState.HALF_OPEN
                else:
                    return self._call_fallback(func, *args, **kwargs)
                    
            try:
                result = func(*args, **kwargs)
                self._on_success()
                return result
                
            except self.config.expected_exception as e:
                self._on_failure()
                if self.config.fallback_function:
                    return self.config.fallback_function(*args, **kwargs)
                raise e
                
    def _should_attempt_reset(self) -> bool:
        """检查是否应该尝试重置断路器"""
        return (self.last_failure_time and 
                time.time() - self.last_failure_time >= self.config.recovery_timeout)
                
    def _on_success(self):
        """成功调用处理"""
        self.failure_count = 0
        self.state = CircuitBreakerState.CLOSED
        
    def _on_failure(self):
        """失败调用处理"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.config.failure_threshold:
            self.state = CircuitBreakerState.OPEN
            
    def _call_fallback(self, func: Callable, *args, **kwargs) -> Any:
        """调用降级函数"""
        if self.config.fallback_function:
            return self.config.fallback_function(*args, **kwargs)
        raise RuntimeError(f"Circuit breaker is OPEN for {func.__name__}")
```

## 24.3 速率限制器

### 令牌桶算法实现
```python
# src/poe2build/resilience/rate_limiter.py

import time
import threading
from typing import Dict, Optional

class TokenBucket:
    """令牌桶实现"""
    
    def __init__(self, capacity: int, refill_rate: float):
        self.capacity = capacity          # 桶容量
        self.refill_rate = refill_rate   # 每秒补充令牌数
        self.tokens = capacity           # 当前令牌数
        self.last_refill = time.time()   # 上次补充时间
        self._lock = threading.RLock()
        
    def consume(self, tokens: int = 1) -> bool:
        """消费令牌"""
        with self._lock:
            self._refill()
            
            if self.tokens >= tokens:
                self.tokens -= tokens
                return True
            return False
            
    def _refill(self):
        """补充令牌"""
        now = time.time()
        elapsed = now - self.last_refill
        new_tokens = elapsed * self.refill_rate
        
        self.tokens = min(self.capacity, self.tokens + new_tokens)
        self.last_refill = now

class RateLimiter:
    """速率限制器 - 管理多个服务的速率限制"""
    
    def __init__(self):
        self.buckets: Dict[str, TokenBucket] = {}
        self._lock = threading.RLock()
        
    def add_limit(self, service: str, requests_per_second: float, 
                  burst_capacity: int = None):
        """为服务添加速率限制"""
        if burst_capacity is None:
            burst_capacity = max(1, int(requests_per_second * 2))
            
        with self._lock:
            self.buckets[service] = TokenBucket(
                capacity=burst_capacity,
                refill_rate=requests_per_second
            )
            
    def allow_request(self, service: str, tokens: int = 1) -> bool:
        """检查是否允许请求"""
        bucket = self.buckets.get(service)
        if not bucket:
            return True  # 未设置限制，允许请求
            
        return bucket.consume(tokens)
        
    def wait_for_token(self, service: str, timeout: float = 10.0) -> bool:
        """等待令牌可用"""
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            if self.allow_request(service):
                return True
            time.sleep(0.1)  # 短暂等待
            
        return False
```

## 24.4 重试处理器

### 指数退避重试
```python
# src/poe2build/resilience/retry_handler.py

import time
import random
import logging
from typing import Callable, Any, Type, Union, List
from functools import wraps

logger = logging.getLogger(__name__)

class RetryConfig:
    """重试配置"""
    
    def __init__(self, 
                 max_attempts: int = 3,
                 base_delay: float = 1.0,
                 max_delay: float = 60.0,
                 backoff_factor: float = 2.0,
                 jitter: bool = True,
                 retry_on: Union[Type[Exception], List[Type[Exception]]] = Exception):
        self.max_attempts = max_attempts
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.backoff_factor = backoff_factor
        self.jitter = jitter
        
        if isinstance(retry_on, type):
            self.retry_exceptions = (retry_on,)
        else:
            self.retry_exceptions = tuple(retry_on)

def retry_with_backoff(config: RetryConfig):
    """重试装饰器"""
    
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            last_exception = None
            
            for attempt in range(config.max_attempts):
                try:
                    return func(*args, **kwargs)
                    
                except config.retry_exceptions as e:
                    last_exception = e
                    
                    if attempt < config.max_attempts - 1:  # 不是最后一次尝试
                        delay = min(
                            config.base_delay * (config.backoff_factor ** attempt),
                            config.max_delay
                        )
                        
                        # 添加抖动避免雷群效应
                        if config.jitter:
                            delay *= (0.5 + random.random() * 0.5)
                            
                        logger.warning(
                            f"Attempt {attempt + 1} failed for {func.__name__}: {e}. "
                            f"Retrying in {delay:.2f}s..."
                        )
                        time.sleep(delay)
                    else:
                        logger.error(
                            f"All {config.max_attempts} attempts failed for {func.__name__}"
                        )
                        
            raise last_exception
            
        return wrapper
    return decorator

class RetryHandler:
    """重试处理器类"""
    
    def __init__(self, config: RetryConfig):
        self.config = config
        
    def execute(self, func: Callable, *args, **kwargs) -> Any:
        """执行带重试的函数调用"""
        retry_decorator = retry_with_backoff(self.config)
        retry_func = retry_decorator(func)
        return retry_func(*args, **kwargs)
```

## 24.5 缓存管理器

### 多层缓存系统
```python
# src/poe2build/resilience/cache_manager.py

import time
import json
import pickle
import threading
from typing import Any, Optional, Dict, Callable
from pathlib import Path
from dataclasses import dataclass

@dataclass
class CacheConfig:
    memory_ttl: int = 300        # 内存缓存TTL(秒)
    disk_ttl: int = 3600         # 磁盘缓存TTL(秒) 
    max_memory_items: int = 1000 # 内存缓存最大条目数
    cache_dir: str = "cache"     # 缓存目录

class CacheManager:
    """多层缓存管理器"""
    
    def __init__(self, config: CacheConfig):
        self.config = config
        self.memory_cache: Dict[str, tuple] = {}  # (value, expire_time)
        self.cache_dir = Path(config.cache_dir)
        self.cache_dir.mkdir(exist_ok=True)
        self._lock = threading.RLock()
        
    def get(self, key: str) -> Optional[Any]:
        """获取缓存值"""
        # 1. 尝试内存缓存
        memory_value = self._get_from_memory(key)
        if memory_value is not None:
            return memory_value
            
        # 2. 尝试磁盘缓存
        disk_value = self._get_from_disk(key)
        if disk_value is not None:
            # 重新放入内存缓存
            self._put_to_memory(key, disk_value, self.config.memory_ttl)
            return disk_value
            
        return None
        
    def put(self, key: str, value: Any, ttl: Optional[int] = None):
        """存储缓存值"""
        memory_ttl = ttl or self.config.memory_ttl
        disk_ttl = ttl or self.config.disk_ttl
        
        # 存储到内存缓存
        self._put_to_memory(key, value, memory_ttl)
        
        # 存储到磁盘缓存  
        self._put_to_disk(key, value, disk_ttl)
        
    def _get_from_memory(self, key: str) -> Optional[Any]:
        """从内存获取"""
        with self._lock:
            if key in self.memory_cache:
                value, expire_time = self.memory_cache[key]
                
                if time.time() < expire_time:
                    return value
                else:
                    # 已过期，删除
                    del self.memory_cache[key]
                    
        return None
        
    def _put_to_memory(self, key: str, value: Any, ttl: int):
        """存储到内存"""
        with self._lock:
            # 检查是否需要清理空间
            if len(self.memory_cache) >= self.config.max_memory_items:
                self._evict_expired_memory()
                
                # 如果还是满的，删除最老的条目
                if len(self.memory_cache) >= self.config.max_memory_items:
                    oldest_key = min(self.memory_cache.keys(), 
                                   key=lambda k: self.memory_cache[k][1])
                    del self.memory_cache[oldest_key]
                    
            expire_time = time.time() + ttl
            self.memory_cache[key] = (value, expire_time)
            
    def _get_from_disk(self, key: str) -> Optional[Any]:
        """从磁盘获取"""
        cache_file = self.cache_dir / f"{key}.cache"
        
        try:
            if cache_file.exists():
                with open(cache_file, 'rb') as f:
                    cached_data = pickle.load(f)
                    
                value, expire_time = cached_data
                
                if time.time() < expire_time:
                    return value
                else:
                    # 已过期，删除文件
                    cache_file.unlink(missing_ok=True)
                    
        except Exception as e:
            # 缓存文件损坏，删除它
            cache_file.unlink(missing_ok=True)
            
        return None
        
    def _put_to_disk(self, key: str, value: Any, ttl: int):
        """存储到磁盘"""
        cache_file = self.cache_dir / f"{key}.cache"
        
        try:
            expire_time = time.time() + ttl
            cached_data = (value, expire_time)
            
            with open(cache_file, 'wb') as f:
                pickle.dump(cached_data, f)
                
        except Exception as e:
            # 序列化失败，忽略磁盘缓存
            pass
            
    def _evict_expired_memory(self):
        """清理过期的内存缓存"""
        current_time = time.time()
        expired_keys = []
        
        for key, (value, expire_time) in self.memory_cache.items():
            if current_time >= expire_time:
                expired_keys.append(key)
                
        for key in expired_keys:
            del self.memory_cache[key]
            
    def clear(self):
        """清空所有缓存"""
        with self._lock:
            self.memory_cache.clear()
            
        # 清空磁盘缓存
        for cache_file in self.cache_dir.glob("*.cache"):
            cache_file.unlink(missing_ok=True)
```

## 24.6 弹性服务包装器

### 综合弹性包装器
```python
# src/poe2build/resilience/__init__.py

from .circuit_breaker import CircuitBreaker, CircuitBreakerConfig
from .rate_limiter import RateLimiter
from .retry_handler import RetryHandler, RetryConfig, retry_with_backoff
from .cache_manager import CacheManager, CacheConfig
from .fallback_provider import FallbackProvider

class ResilientService:
    """弹性服务包装器 - 集成所有弹性模式"""
    
    def __init__(self, 
                 service_name: str,
                 circuit_breaker_config: CircuitBreakerConfig = None,
                 retry_config: RetryConfig = None,
                 cache_config: CacheConfig = None,
                 rate_limit_rps: float = None):
                 
        self.service_name = service_name
        
        # 初始化各种弹性组件
        if circuit_breaker_config:
            self.circuit_breaker = CircuitBreaker(circuit_breaker_config)
        else:
            self.circuit_breaker = None
            
        if retry_config:
            self.retry_handler = RetryHandler(retry_config)
        else:
            self.retry_handler = None
            
        if cache_config:
            self.cache_manager = CacheManager(cache_config)
        else:
            self.cache_manager = None
            
        if rate_limit_rps:
            self.rate_limiter = RateLimiter()
            self.rate_limiter.add_limit(service_name, rate_limit_rps)
        else:
            self.rate_limiter = None
            
    def call(self, func, *args, cache_key: str = None, **kwargs):
        """执行弹性调用"""
        
        # 1. 检查缓存
        if cache_key and self.cache_manager:
            cached_result = self.cache_manager.get(cache_key)
            if cached_result is not None:
                return cached_result
                
        # 2. 检查速率限制
        if self.rate_limiter:
            if not self.rate_limiter.wait_for_token(self.service_name, timeout=5.0):
                raise RuntimeError(f"Rate limit exceeded for {self.service_name}")
                
        # 3. 定义执行函数
        def execute():
            if self.circuit_breaker:
                return self.circuit_breaker.call(func, *args, **kwargs)
            else:
                return func(*args, **kwargs)
                
        # 4. 应用重试
        if self.retry_handler:
            result = self.retry_handler.execute(execute)
        else:
            result = execute()
            
        # 5. 缓存结果
        if cache_key and self.cache_manager:
            self.cache_manager.put(cache_key, result)
            
        return result

# 预配置的弹性服务实例
def create_poe2_scout_service() -> ResilientService:
    """创建PoE2 Scout服务的弹性包装器"""
    return ResilientService(
        service_name="poe2_scout",
        circuit_breaker_config=CircuitBreakerConfig(
            failure_threshold=3,
            recovery_timeout=60.0
        ),
        retry_config=RetryConfig(
            max_attempts=3,
            base_delay=2.0,
            backoff_factor=2.0
        ),
        cache_config=CacheConfig(
            memory_ttl=300,    # 5分钟内存缓存
            disk_ttl=1800      # 30分钟磁盘缓存
        ),
        rate_limit_rps=0.5     # 每2秒1个请求
    )

def create_poe2db_service() -> ResilientService:
    """创建PoE2DB服务的弹性包装器"""  
    return ResilientService(
        service_name="poe2db",
        circuit_breaker_config=CircuitBreakerConfig(
            failure_threshold=5,
            recovery_timeout=30.0
        ),
        retry_config=RetryConfig(
            max_attempts=2,
            base_delay=1.0,
            backoff_factor=1.5
        ),
        cache_config=CacheConfig(
            memory_ttl=600,    # 10分钟内存缓存
            disk_ttl=3600      # 1小时磁盘缓存
        ),
        rate_limit_rps=1.0     # 每秒1个请求
    )

def create_poe_ninja_service() -> ResilientService:
    """创建poe.ninja服务的弹性包装器"""
    return ResilientService(
        service_name="poe_ninja", 
        circuit_breaker_config=CircuitBreakerConfig(
            failure_threshold=2,
            recovery_timeout=120.0
        ),
        retry_config=RetryConfig(
            max_attempts=3,
            base_delay=3.0,
            backoff_factor=3.0
        ),
        cache_config=CacheConfig(
            memory_ttl=900,    # 15分钟内存缓存
            disk_ttl=7200      # 2小时磁盘缓存
        ),
        rate_limit_rps=0.2     # 每5秒1个请求
    )
```

## 24.7 降级服务提供者

### 实现优雅降级
```python
# src/poe2build/resilience/fallback_provider.py

import logging
from typing import Dict, Any, List, Optional
from abc import ABC, abstractmethod

logger = logging.getLogger(__name__)

class FallbackProvider(ABC):
    """降级服务提供者抽象基类"""
    
    @abstractmethod
    def provide_fallback(self, service_name: str, operation: str, *args, **kwargs) -> Any:
        """提供降级服务"""
        pass

class PoE2FallbackProvider(FallbackProvider):
    """PoE2专用降级服务提供者"""
    
    def __init__(self):
        # 预置的降级数据
        self.fallback_data = {
            "market_data": self._load_fallback_market_data(),
            "build_templates": self._load_fallback_build_templates(),
            "game_data": self._load_fallback_game_data()
        }
        
    def provide_fallback(self, service_name: str, operation: str, *args, **kwargs) -> Any:
        """提供降级服务"""
        
        if service_name == "poe2_scout":
            return self._provide_scout_fallback(operation, *args, **kwargs)
        elif service_name == "poe2db":
            return self._provide_db_fallback(operation, *args, **kwargs)
        elif service_name == "poe_ninja":
            return self._provide_ninja_fallback(operation, *args, **kwargs)
        else:
            logger.warning(f"No fallback available for service: {service_name}")
            return self._provide_generic_fallback(operation, *args, **kwargs)
            
    def _provide_scout_fallback(self, operation: str, *args, **kwargs) -> Dict[str, Any]:
        """PoE2 Scout降级服务"""
        
        if operation == "get_market_data":
            return {
                "status": "fallback",
                "data": self.fallback_data["market_data"],
                "message": "使用缓存的市场数据 - PoE2 Scout服务不可用"
            }
        elif operation == "get_build_trends":
            return {
                "status": "fallback",
                "trends": self._get_fallback_trends(),
                "message": "使用预设趋势数据 - PoE2 Scout服务不可用"
            }
        else:
            return self._provide_generic_fallback(operation, *args, **kwargs)
            
    def _provide_db_fallback(self, operation: str, *args, **kwargs) -> Dict[str, Any]:
        """PoE2DB降级服务"""
        
        if operation == "get_skill_data":
            return {
                "status": "fallback", 
                "skills": self.fallback_data["game_data"]["skills"],
                "message": "使用离线技能数据 - PoE2DB服务不可用"
            }
        elif operation == "get_item_data":
            return {
                "status": "fallback",
                "items": self.fallback_data["game_data"]["items"], 
                "message": "使用离线物品数据 - PoE2DB服务不可用"
            }
        else:
            return self._provide_generic_fallback(operation, *args, **kwargs)
            
    def _provide_ninja_fallback(self, operation: str, *args, **kwargs) -> Dict[str, Any]:
        """poe.ninja降级服务"""
        
        if operation == "get_popular_builds":
            return {
                "status": "fallback",
                "builds": self.fallback_data["build_templates"],
                "message": "使用预设构筑模板 - poe.ninja服务不可用"
            }
        else:
            return self._provide_generic_fallback(operation, *args, **kwargs)
            
    def _provide_generic_fallback(self, operation: str, *args, **kwargs) -> Dict[str, Any]:
        """通用降级服务"""
        
        return {
            "status": "error",
            "message": f"服务暂时不可用，请稍后重试。操作: {operation}",
            "fallback": True
        }
        
    def _load_fallback_market_data(self) -> Dict[str, Any]:
        """加载降级市场数据"""
        
        return {
            "currency": {
                "divine": {"chaos_value": 180, "trend": "stable"},
                "exalted": {"chaos_value": 45, "trend": "rising"}
            },
            "popular_items": [
                {"name": "Kaom's Heart", "type": "Body Armour", "avg_price": 12},
                {"name": "Shaper of Storms", "type": "Unique Jewel", "avg_price": 8}
            ]
        }
        
    def _load_fallback_build_templates(self) -> List[Dict[str, Any]]:
        """加载降级构筑模板"""
        
        return [
            {
                "name": "Lightning Arrow Ranger",
                "class": "Ranger", 
                "ascendancy": "Deadeye",
                "main_skill": "Lightning Arrow",
                "estimated_dps": 850000,
                "difficulty": "medium",
                "budget_tier": "medium"
            },
            {
                "name": "Ice Nova Witch",
                "class": "Witch",
                "ascendancy": "Chronomancer", 
                "main_skill": "Ice Nova",
                "estimated_dps": 1200000,
                "difficulty": "high",
                "budget_tier": "high"
            }
        ]
        
    def _load_fallback_game_data(self) -> Dict[str, Any]:
        """加载降级游戏数据"""
        
        return {
            "skills": [
                {"name": "Lightning Arrow", "type": "Bow", "damage_type": "Lightning"},
                {"name": "Ice Nova", "type": "Spell", "damage_type": "Cold"}
            ],
            "items": [
                {"name": "Kaom's Heart", "type": "Body Armour", "tier": "Unique"},
                {"name": "Belly of the Beast", "type": "Body Armour", "tier": "Unique"}
            ]
        }
        
    def _get_fallback_trends(self) -> Dict[str, Any]:
        """获取降级趋势数据"""
        
        return {
            "popular_classes": ["Ranger", "Witch", "Warrior"],
            "trending_skills": ["Lightning Arrow", "Ice Nova", "Earthquake"],
            "meta_shifts": {
                "bow_builds": "rising",
                "spell_builds": "stable", 
                "melee_builds": "declining"
            }
        }
```

要求实现完整的弹性系统，确保PoE2智能构筑生成器在面对网络故障、服务不可用等情况时能够优雅降级，保持系统稳定运行。