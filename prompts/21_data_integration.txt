请实现PoE2智能构筑生成器GUI与后端数据系统的完整集成：

## 21.1 集成架构设计

### 数据流架构图
```
┌─── GUI Frontend Layer ───────────────────────────────────────────┐
│  ┌─ Views ──────┐  ┌─ Presenters ─┐  ┌─ UI Controllers ───────┐   │
│  │ • MainWindow │  │ • Presenters │  │ • AsyncTaskManager     │   │
│  │ • BuildForm  │  │ • ViewModels │  │ • ProgressController   │   │
│  │ • Results    │  │ • Validators │  │ • ErrorHandler         │   │
│  └──────────────┘  └──────────────┘  └────────────────────────┘   │
└───────────────────────────────────────────────────────────────────┘
         ↕ Qt Signals/Slots + Async Workers
┌─── Integration Layer ────────────────────────────────────────────┐
│  ┌─ OrchestratorClient ┐  ┌─ DataFlowManager ───────────────────┐ │
│  │ • API调用封装        │  │ • 数据转换和验证                     │ │
│  │ • 连接管理          │  │ • 缓存管理                           │ │
│  │ • 错误处理          │  │ • 状态同步                           │ │
│  └─────────────────────┘  └─────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────────────┘
         ↕ Direct Python Calls + Queue Communication
┌─── Backend Services Layer ───────────────────────────────────────┐
│  ┌─ PoE2AIOrchestrator ──────────────────────────────────────────┐ │
│  │  ┌─ RAG System ──┐  ┌─ PoB2Integration ─┐  ┌─ DataSources ─┐  │ │
│  │  │ • AI引擎      │  │ • 本地PoB2       │  │ • API客户端   │  │ │
│  │  │ • 向量化     │  │ • Web PoB2       │  │ • 数据缓存    │  │ │
│  │  │ • 推荐算法    │  │ • 计算引擎       │  │ • 容灾机制    │  │ │
│  │  └──────────────┘  └──────────────────┘  └───────────────┘  │ │
│  └───────────────────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────────────┘
```

### 集成通信模式
1. **同步调用**: 简单数据查询、配置获取
2. **异步任务**: 构筑生成、数据更新、PoB2计算  
3. **事件驱动**: 状态变化通知、进度更新
4. **流式处理**: 实时日志、进度反馈

## 21.2 OrchestratorClient 实现

### 核心客户端类
```python
class OrchestratorClient(QObject):
    """PoE2AIOrchestrator的GUI客户端封装"""
    
    # 信号定义
    build_generation_started = pyqtSignal()
    build_generation_progress = pyqtSignal(int, str)  # 进度百分比, 状态消息
    build_generation_completed = pyqtSignal(dict)    # 生成结果
    build_generation_failed = pyqtSignal(str)        # 错误信息
    
    connection_status_changed = pyqtSignal(bool)     # 连接状态变化
    pob2_status_changed = pyqtSignal(str)           # PoB2状态变化
    system_health_updated = pyqtSignal(dict)        # 系统健康状态
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # 后端引用
        self._orchestrator = None
        self._is_connected = False
        self._last_health_check = None
        
        # 异步任务管理
        self.task_manager = AsyncTaskManager(self)
        self.progress_tracker = ProgressTracker(self)
        
        # 数据缓存
        self.data_cache = DataCache()
        self.request_queue = RequestQueue()
        
        # 初始化连接
        self._initialize_connection()
        
    def _initialize_connection(self):
        """初始化与后端的连接"""
        try:
            # 导入并创建后端实例
            from poe2_ai_orchestrator import PoE2AIOrchestrator
            
            self._orchestrator = PoE2AIOrchestrator()
            self._is_connected = True
            
            # 设置日志回调
            self._setup_logging_integration()
            
            # 执行初始健康检查
            self._perform_health_check()
            
            self.connection_status_changed.emit(True)
            
        except Exception as e:
            logger.error(f"Failed to initialize orchestrator connection: {e}")
            self._is_connected = False
            self.connection_status_changed.emit(False)
            
    def _setup_logging_integration(self):
        """设置日志集成"""
        # 创建Qt日志处理器，将后端日志转发到GUI
        class QtLogHandler(logging.Handler):
            def __init__(self, client):
                super().__init__()
                self.client = client
                
            def emit(self, record):
                # 将日志记录转发到GUI日志系统
                log_entry = {
                    'timestamp': record.created,
                    'level': record.levelname,
                    'logger': record.name,
                    'message': record.getMessage(),
                    'module': getattr(record, 'module', ''),
                    'function': getattr(record, 'funcName', '')
                }
                
                # 通过信号发送到GUI
                QMetaObject.invokeMethod(
                    self.client.parent(),
                    "_handle_backend_log",
                    Qt.QueuedConnection,
                    Q_ARG(dict, log_entry)
                )
        
        # 为后端添加Qt日志处理器
        qt_handler = QtLogHandler(self)
        logging.getLogger('poe2build').addHandler(qt_handler)
        
    def generate_build_async(self, build_request):
        """异步生成构筑"""
        if not self._is_connected:
            self.build_generation_failed.emit("后端连接未建立")
            return
            
        # 验证请求数据
        if not self._validate_build_request(build_request):
            self.build_generation_failed.emit("构筑请求数据无效")
            return
            
        # 创建异步任务
        task = BuildGenerationTask(
            orchestrator=self._orchestrator,
            request=build_request,
            parent=self
        )
        
        # 连接任务信号
        task.started.connect(self.build_generation_started)
        task.progress_updated.connect(self.build_generation_progress)
        task.completed.connect(self.build_generation_completed)
        task.failed.connect(self.build_generation_failed)
        
        # 提交任务
        self.task_manager.submit_task(task)
        
    def _validate_build_request(self, request):
        """验证构筑请求"""
        required_fields = ['game', 'preferences']
        
        if not isinstance(request, dict):
            return False
            
        for field in required_fields:
            if field not in request:
                logger.warning(f"Missing required field: {field}")
                return False
                
        # 验证preferences结构
        prefs = request.get('preferences', {})
        if 'class' not in prefs:
            logger.warning("Missing class in preferences")
            return False
            
        return True
        
    def get_system_health_async(self):
        """异步获取系统健康状态"""
        def health_check_worker():
            try:
                if self._orchestrator:
                    health_data = self._orchestrator.health_check()
                    
                    # 格式化健康数据为GUI友好的格式
                    formatted_health = self._format_health_data(health_data)
                    
                    # 缓存结果
                    self._last_health_check = formatted_health
                    self.data_cache.set('system_health', formatted_health, ttl=30)
                    
                    return formatted_health
                else:
                    return {"status": "disconnected", "components": {}}
                    
            except Exception as e:
                logger.error(f"Health check failed: {e}")
                return {"status": "error", "error": str(e)}
        
        # 异步执行健康检查
        future = self.task_manager.submit_function(health_check_worker)
        future.add_done_callback(
            lambda f: self.system_health_updated.emit(f.result())
        )
        
    def _format_health_data(self, raw_health):
        """格式化健康数据"""
        return {
            "timestamp": time.time(),
            "overall_status": raw_health.get("status", "unknown"),
            "components": {
                "pob2_integration": {
                    "status": raw_health.get("pob2_status", "unknown"),
                    "details": raw_health.get("pob2_details", {})
                },
                "data_sources": {
                    "status": raw_health.get("data_sources_status", "unknown"),
                    "details": raw_health.get("data_sources_details", {})
                },
                "rag_system": {
                    "status": raw_health.get("rag_status", "unknown"), 
                    "details": raw_health.get("rag_details", {})
                }
            },
            "performance_metrics": raw_health.get("performance", {}),
            "resource_usage": raw_health.get("resources", {})
        }
        
    def get_available_classes(self):
        """获取可用职业列表"""
        cached = self.data_cache.get('available_classes')
        if cached:
            return cached
            
        try:
            if self._orchestrator:
                classes = self._orchestrator.get_available_classes()
                self.data_cache.set('available_classes', classes, ttl=3600)
                return classes
            else:
                # 返回默认数据
                return self._get_default_classes()
        except Exception as e:
            logger.error(f"Failed to get available classes: {e}")
            return self._get_default_classes()
            
    def _get_default_classes(self):
        """获取默认职业数据"""
        return {
            "Witch": {"name": "法师", "ascendancies": ["Infernalist", "Chronomancer"]},
            "Ranger": {"name": "游侠", "ascendancies": ["Deadeye", "Pathfinder"]},
            "Monk": {"name": "武僧", "ascendancies": ["Invoker", "Acolyte"]},
            "Knight": {"name": "骑士", "ascendancies": ["Guardian", "Armiger"]},
            "Sorceress": {"name": "女巫", "ascendancies": ["Stormweaver", "Witch Hunter"]},
            "Mercenary": {"name": "佣兵", "ascendancies": ["Gemling", "Artificer"]}
        }
        
    def is_pob2_available(self):
        """检查PoB2是否可用"""
        cached = self.data_cache.get('pob2_status')
        if cached and time.time() - cached['timestamp'] < 60:
            return cached['available']
            
        try:
            if self._orchestrator:
                available = self._orchestrator.is_pob2_available()
                self.data_cache.set('pob2_status', {
                    'available': available,
                    'timestamp': time.time()
                }, ttl=60)
                return available
            return False
        except Exception as e:
            logger.error(f"Failed to check PoB2 status: {e}")
            return False
            
    def export_to_pob2_async(self, build_data):
        """异步导出构筑到PoB2"""
        def export_worker():
            try:
                if not self._orchestrator:
                    raise Exception("后端未连接")
                    
                # 调用后端导出功能
                result = self._orchestrator.export_to_pob2(build_data)
                return {
                    "success": True,
                    "pob_code": result.get("pob_code", ""),
                    "file_path": result.get("file_path", ""),
                    "message": "导出成功"
                }
            except Exception as e:
                return {
                    "success": False,
                    "error": str(e),
                    "message": f"导出失败: {e}"
                }
        
        future = self.task_manager.submit_function(export_worker)
        return future  # 返回Future对象供调用者处理
        
    def check_network_status(self):
        """检查网络连接状态"""
        cached = self.data_cache.get('network_status')
        if cached and time.time() - cached['timestamp'] < 30:
            return cached['online']
            
        try:
            # 简单的网络检查
            import urllib.request
            urllib.request.urlopen('http://www.google.com', timeout=5)
            
            self.data_cache.set('network_status', {
                'online': True,
                'timestamp': time.time()
            }, ttl=30)
            return True
            
        except:
            self.data_cache.set('network_status', {
                'online': False,
                'timestamp': time.time()
            }, ttl=30)
            return False
            
    def disconnect(self):
        """断开连接"""
        if self._orchestrator:
            # 执行清理操作
            try:
                self._orchestrator.cleanup()
            except:
                pass
                
        self._orchestrator = None
        self._is_connected = False
        self.connection_status_changed.emit(False)
        
        # 停止所有任务
        self.task_manager.shutdown()
```

## 21.3 异步任务管理

### AsyncTaskManager 实现
```python
class AsyncTaskManager(QObject):
    """异步任务管理器"""
    
    task_started = pyqtSignal(str)      # 任务ID
    task_completed = pyqtSignal(str)    # 任务ID
    task_failed = pyqtSignal(str, str)  # 任务ID, 错误信息
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # 线程池
        self.thread_pool = QThreadPool()
        self.thread_pool.setMaxThreadCount(4)  # 最多4个并发任务
        
        # 任务跟踪
        self.active_tasks = {}
        self.task_history = []
        
        # 任务队列
        self.pending_tasks = queue.Queue()
        self.high_priority_tasks = queue.Queue()
        
    def submit_task(self, task):
        """提交异步任务"""
        if not isinstance(task, AsyncTask):
            raise ValueError("Task must be an instance of AsyncTask")
            
        task_id = task.task_id
        self.active_tasks[task_id] = {
            'task': task,
            'start_time': time.time(),
            'status': 'pending'
        }
        
        # 连接任务信号
        task.started.connect(lambda: self._on_task_started(task_id))
        task.completed.connect(lambda result: self._on_task_completed(task_id, result))
        task.failed.connect(lambda error: self._on_task_failed(task_id, error))
        
        # 提交到线程池
        self.thread_pool.start(task)
        
        return task_id
        
    def submit_function(self, func, *args, **kwargs):
        """提交函数作为异步任务"""
        task = FunctionTask(func, args, kwargs)
        self.submit_task(task)
        return task.future
        
    def _on_task_started(self, task_id):
        """任务开始处理"""
        if task_id in self.active_tasks:
            self.active_tasks[task_id]['status'] = 'running'
            self.task_started.emit(task_id)
            
    def _on_task_completed(self, task_id, result):
        """任务完成处理"""
        if task_id in self.active_tasks:
            task_info = self.active_tasks[task_id]
            task_info['status'] = 'completed'
            task_info['end_time'] = time.time()
            task_info['result'] = result
            
            # 移到历史记录
            self.task_history.append(task_info)
            del self.active_tasks[task_id]
            
            self.task_completed.emit(task_id)
            
    def _on_task_failed(self, task_id, error):
        """任务失败处理"""
        if task_id in self.active_tasks:
            task_info = self.active_tasks[task_id]
            task_info['status'] = 'failed'
            task_info['end_time'] = time.time()
            task_info['error'] = error
            
            # 移到历史记录
            self.task_history.append(task_info)
            del self.active_tasks[task_id]
            
            self.task_failed.emit(task_id, error)
            
    def cancel_task(self, task_id):
        """取消任务"""
        if task_id in self.active_tasks:
            task = self.active_tasks[task_id]['task']
            task.cancel()
            
    def get_task_status(self, task_id):
        """获取任务状态"""
        if task_id in self.active_tasks:
            return self.active_tasks[task_id]['status']
        
        # 检查历史记录
        for task_info in self.task_history:
            if task_info['task'].task_id == task_id:
                return task_info['status']
                
        return 'unknown'
        
    def get_active_tasks(self):
        """获取活跃任务列表"""
        return list(self.active_tasks.keys())
        
    def shutdown(self):
        """关闭任务管理器"""
        # 等待所有任务完成或超时
        self.thread_pool.waitForDone(5000)  # 5秒超时
        
        # 清理资源
        self.active_tasks.clear()
        self.task_history.clear()

class AsyncTask(QRunnable):
    """异步任务基类"""
    
    started = pyqtSignal()
    completed = pyqtSignal(object)
    failed = pyqtSignal(str)
    progress_updated = pyqtSignal(int, str)
    
    def __init__(self):
        super().__init__()
        self.signals = AsyncTaskSignals()
        self.task_id = str(uuid.uuid4())
        self.is_cancelled = False
        
    def run(self):
        """执行任务"""
        try:
            self.signals.started.emit()
            result = self.execute()
            
            if not self.is_cancelled:
                self.signals.completed.emit(result)
                
        except Exception as e:
            self.signals.failed.emit(str(e))
            
    def execute(self):
        """子类需要实现的执行方法"""
        raise NotImplementedError
        
    def cancel(self):
        """取消任务"""
        self.is_cancelled = True
        
    def update_progress(self, percentage, message=""):
        """更新进度"""
        self.signals.progress_updated.emit(percentage, message)

class AsyncTaskSignals(QObject):
    """异步任务信号"""
    started = pyqtSignal()
    completed = pyqtSignal(object)
    failed = pyqtSignal(str)
    progress_updated = pyqtSignal(int, str)

class BuildGenerationTask(AsyncTask):
    """构筑生成任务"""
    
    def __init__(self, orchestrator, request, parent=None):
        super().__init__()
        self.orchestrator = orchestrator
        self.request = request
        self.parent = parent
        
    def execute(self):
        """执行构筑生成"""
        try:
            # 阶段1: 数据准备
            self.update_progress(10, "准备数据...")
            
            if self.is_cancelled:
                return None
                
            # 阶段2: RAG查询
            self.update_progress(25, "分析相似构筑...")
            
            if self.is_cancelled:
                return None
                
            # 阶段3: AI生成
            self.update_progress(50, "AI生成构筑...")
            
            # 调用后端生成构筑
            result = self.orchestrator.generate_build_recommendation(self.request)
            
            if self.is_cancelled:
                return None
                
            # 阶段4: PoB2计算
            self.update_progress(75, "PoB2计算统计...")
            
            # 如果有PoB2集成，进行计算
            if result and 'recommendations' in result:
                for build in result['recommendations']:
                    if self.is_cancelled:
                        return None
                    # 这里可以调用PoB2计算增强数据
                    
            # 阶段5: 完成
            self.update_progress(100, "生成完成")
            
            return result
            
        except Exception as e:
            logger.error(f"Build generation failed: {e}")
            raise
```

## 21.4 进度反馈系统

### ProgressTracker 实现
```python
class ProgressTracker(QObject):
    """进度跟踪器"""
    
    progress_changed = pyqtSignal(str, int, str)  # 任务ID, 百分比, 消息
    stage_changed = pyqtSignal(str, str, str)     # 任务ID, 旧阶段, 新阶段
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.task_progress = {}
        
    def start_tracking(self, task_id, stages):
        """开始跟踪任务进度"""
        self.task_progress[task_id] = {
            'stages': stages,
            'current_stage': 0,
            'stage_progress': 0,
            'overall_progress': 0,
            'start_time': time.time()
        }
        
    def update_stage_progress(self, task_id, progress, message=""):
        """更新当前阶段进度"""
        if task_id not in self.task_progress:
            return
            
        task_info = self.task_progress[task_id]
        task_info['stage_progress'] = progress
        
        # 计算整体进度
        stages_count = len(task_info['stages'])
        completed_stages = task_info['current_stage']
        current_stage_weight = 1.0 / stages_count
        
        overall_progress = (completed_stages / stages_count * 100 + 
                          progress * current_stage_weight)
        
        task_info['overall_progress'] = min(100, int(overall_progress))
        
        self.progress_changed.emit(task_id, task_info['overall_progress'], message)
        
    def advance_stage(self, task_id, message=""):
        """前进到下一阶段"""
        if task_id not in self.task_progress:
            return
            
        task_info = self.task_progress[task_id]
        old_stage = task_info['current_stage']
        
        if old_stage < len(task_info['stages']) - 1:
            task_info['current_stage'] += 1
            task_info['stage_progress'] = 0
            
            new_stage = task_info['current_stage']
            
            old_stage_name = task_info['stages'][old_stage] if old_stage >= 0 else ""
            new_stage_name = task_info['stages'][new_stage]
            
            self.stage_changed.emit(task_id, old_stage_name, new_stage_name)
            
            # 更新整体进度
            overall_progress = int((new_stage + 1) / len(task_info['stages']) * 100)
            task_info['overall_progress'] = overall_progress
            
            self.progress_changed.emit(task_id, overall_progress, message)
            
    def finish_tracking(self, task_id):
        """结束进度跟踪"""
        if task_id in self.task_progress:
            del self.task_progress[task_id]
            
    def get_progress(self, task_id):
        """获取任务进度"""
        return self.task_progress.get(task_id, {})
```

## 21.5 数据转换和验证

### DataFlowManager 实现
```python
class DataFlowManager(QObject):
    """数据流管理器"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # 数据转换器
        self.converters = {
            'build_request': BuildRequestConverter(),
            'build_response': BuildResponseConverter(),
            'health_data': HealthDataConverter(),
            'class_data': ClassDataConverter()
        }
        
        # 数据验证器
        self.validators = {
            'build_request': BuildRequestValidator(),
            'user_preferences': UserPreferencesValidator()
        }
        
    def convert_gui_to_backend(self, data_type, gui_data):
        """将GUI数据转换为后端格式"""
        converter = self.converters.get(data_type)
        if not converter:
            raise ValueError(f"No converter found for data type: {data_type}")
            
        try:
            backend_data = converter.gui_to_backend(gui_data)
            return backend_data
        except Exception as e:
            logger.error(f"Data conversion failed: {e}")
            raise
            
    def convert_backend_to_gui(self, data_type, backend_data):
        """将后端数据转换为GUI格式"""
        converter = self.converters.get(data_type)
        if not converter:
            raise ValueError(f"No converter found for data type: {data_type}")
            
        try:
            gui_data = converter.backend_to_gui(backend_data)
            return gui_data
        except Exception as e:
            logger.error(f"Data conversion failed: {e}")
            raise
            
    def validate_data(self, data_type, data):
        """验证数据"""
        validator = self.validators.get(data_type)
        if not validator:
            return True  # 如果没有验证器，认为有效
            
        try:
            return validator.validate(data)
        except Exception as e:
            logger.error(f"Data validation failed: {e}")
            return False

class BuildRequestConverter:
    """构筑请求数据转换器"""
    
    def gui_to_backend(self, gui_data):
        """GUI数据转换为后端格式"""
        # GUI数据结构:
        # {
        #     'selected_class': 'Witch',
        #     'selected_ascendancy': 'Infernalist', 
        #     'build_goal': 'endgame_content',
        #     'budget_amount': 15,
        #     'budget_currency': 'Divine Orb',
        #     'advanced_options': {...}
        # }
        
        backend_request = {
            'game': 'poe2',
            'mode': 'standard',
            'preferences': {
                'class': gui_data.get('selected_class'),
                'ascendancy': gui_data.get('selected_ascendancy'),
                'style': self._convert_build_style(gui_data),
                'goal': gui_data.get('build_goal', 'balanced'),
                'budget': {
                    'amount': gui_data.get('budget_amount', 10),
                    'currency': self._convert_currency_name(
                        gui_data.get('budget_currency', 'Divine Orb')
                    )
                },
                'pob2_integration': {
                    'generate_import_code': True,
                    'calculate_stats': True,
                    'validate_build': True
                }
            }
        }
        
        # 添加高级选项
        advanced = gui_data.get('advanced_options', {})
        if advanced:
            backend_request['preferences'].update({
                'defensive_priority': advanced.get('defensive_priority', 'balanced'),
                'damage_type_preference': advanced.get('damage_type_preference'),
                'skill_requirements': advanced.get('skill_requirements', []),
                'item_constraints': advanced.get('item_constraints', {})
            })
            
        return backend_request
        
    def backend_to_gui(self, backend_data):
        """后端数据转换为GUI格式"""
        # 后端返回的构筑推荐数据转换为GUI展示格式
        gui_data = {
            'recommendations': [],
            'metadata': {
                'generation_time': backend_data.get('generation_time'),
                'rag_confidence': backend_data.get('rag_confidence', 0),
                'total_builds': len(backend_data.get('recommendations', []))
            }
        }
        
        for build in backend_data.get('recommendations', []):
            gui_build = {
                'id': build.get('build_id'),
                'name': build.get('build_name'),
                'class': build.get('character_class'),
                'ascendancy': build.get('ascendancy'),
                'level': build.get('level', 90),
                
                # 统计数据
                'dps': build.get('total_dps', 0),
                'life': build.get('life_pool', 0),
                'energy_shield': build.get('energy_shield', 0),
                'resistances': build.get('max_resistance', 75),
                
                # PoB2数据
                'pob_code': build.get('pob2_import_code', ''),
                'pob2_stats': build.get('pob2_stats', {}),
                
                # 装备和技能
                'gear_summary': build.get('gear_summary', {}),
                'skill_gems': build.get('skill_gems', []),
                'passive_tree': build.get('passive_tree', {}),
                
                # 元数据
                'confidence_score': build.get('confidence_score', 0),
                'estimated_cost': build.get('estimated_cost', {}),
                'tags': build.get('tags', [])
            }
            
            gui_data['recommendations'].append(gui_build)
            
        return gui_data
        
    def _convert_build_style(self, gui_data):
        """转换构筑风格"""
        # 根据职业和用户选择推断构筑风格
        class_name = gui_data.get('selected_class', '')
        ascendancy = gui_data.get('selected_ascendancy', '')
        
        style_mapping = {
            'Witch': 'spell_caster',
            'Ranger': 'bow',
            'Monk': 'melee_unarmed',
            'Knight': 'melee_sword_board',
            'Sorceress': 'spell_caster',
            'Mercenary': 'ranged_crossbow'
        }
        
        return style_mapping.get(class_name, 'balanced')
        
    def _convert_currency_name(self, gui_currency):
        """转换货币名称"""
        currency_mapping = {
            'Chaos Orb': 'chaos',
            'Divine Orb': 'divine',
            'Exalted Orb': 'exalted'
        }
        
        return currency_mapping.get(gui_currency, 'divine')

class BuildRequestValidator:
    """构筑请求验证器"""
    
    def validate(self, data):
        """验证构筑请求数据"""
        errors = []
        
        # 必需字段检查
        if not data.get('selected_class'):
            errors.append("必须选择职业")
            
        if not data.get('build_goal'):
            errors.append("必须选择构筑目标")
            
        # 预算验证
        budget_amount = data.get('budget_amount', 0)
        if budget_amount <= 0:
            errors.append("预算金额必须大于0")
            
        # 高级选项验证
        advanced = data.get('advanced_options', {})
        if advanced:
            skill_reqs = advanced.get('skill_requirements', [])
            if len(skill_reqs) > 10:
                errors.append("技能需求不能超过10个")
                
        if errors:
            raise ValueError(f"验证失败: {', '.join(errors)}")
            
        return True
```

## 21.6 错误处理和恢复

### 错误处理系统
```python
class ErrorHandler(QObject):
    """GUI错误处理器"""
    
    error_occurred = pyqtSignal(str, str, dict)  # 级别, 消息, 详情
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.error_history = []
        self.retry_strategies = {
            'network_error': NetworkRetryStrategy(),
            'backend_error': BackendRetryStrategy(),
            'validation_error': ValidationErrorStrategy()
        }
        
    def handle_error(self, error_type, error, context=None):
        """处理错误"""
        error_info = {
            'timestamp': time.time(),
            'type': error_type,
            'message': str(error),
            'context': context or {},
            'handled': False
        }
        
        # 记录错误
        self.error_history.append(error_info)
        logger.error(f"GUI Error [{error_type}]: {error}", extra={'context': context})
        
        # 尝试恢复
        recovery_result = self._attempt_recovery(error_type, error, context)
        error_info['handled'] = recovery_result.get('recovered', False)
        
        # 用户通知
        self._notify_user(error_type, error, recovery_result, context)
        
        # 发射错误信号
        self.error_occurred.emit(error_type, str(error), error_info)
        
        return recovery_result
        
    def _attempt_recovery(self, error_type, error, context):
        """尝试错误恢复"""
        strategy = self.retry_strategies.get(error_type)
        if not strategy:
            return {'recovered': False, 'message': '无法自动恢复'}
            
        try:
            return strategy.attempt_recovery(error, context)
        except Exception as recovery_error:
            logger.error(f"Recovery failed: {recovery_error}")
            return {'recovered': False, 'message': f'恢复失败: {recovery_error}'}
            
    def _notify_user(self, error_type, error, recovery_result, context):
        """通知用户错误情况"""
        if recovery_result.get('recovered'):
            # 成功恢复，显示成功消息
            QMetaObject.invokeMethod(
                self.parent(),
                "_show_recovery_success",
                Qt.QueuedConnection,
                Q_ARG(str, recovery_result.get('message', '问题已自动解决'))
            )
        else:
            # 无法恢复，显示错误对话框
            error_level = self._classify_error_level(error_type, error)
            
            QMetaObject.invokeMethod(
                self.parent(),
                "_show_error_dialog", 
                Qt.QueuedConnection,
                Q_ARG(str, error_level),
                Q_ARG(str, str(error)),
                Q_ARG(dict, context or {})
            )
            
    def _classify_error_level(self, error_type, error):
        """分类错误级别"""
        if error_type in ['network_error', 'backend_connection']:
            return 'warning'
        elif error_type in ['validation_error', 'user_input_error']:
            return 'info'
        elif error_type in ['system_error', 'critical_failure']:
            return 'critical'
        else:
            return 'error'

class NetworkRetryStrategy:
    """网络错误重试策略"""
    
    def attempt_recovery(self, error, context):
        """尝试网络恢复"""
        max_retries = 3
        retry_delay = [1, 2, 5]  # 递增延迟
        
        for attempt in range(max_retries):
            time.sleep(retry_delay[attempt])
            
            # 尝试重新连接
            if self._test_network_connection():
                return {
                    'recovered': True,
                    'message': f'网络连接已恢复 (尝试 {attempt + 1}/{max_retries})',
                    'attempts': attempt + 1
                }
                
        return {
            'recovered': False,
            'message': f'网络连接失败，已尝试 {max_retries} 次',
            'attempts': max_retries
        }
        
    def _test_network_connection(self):
        """测试网络连接"""
        try:
            import urllib.request
            urllib.request.urlopen('http://www.google.com', timeout=5)
            return True
        except:
            return False
```

## 21.7 性能优化和缓存

### 数据缓存系统
```python
class DataCache:
    """数据缓存系统"""
    
    def __init__(self, max_size=1000, default_ttl=3600):
        self.cache = {}
        self.access_times = {}
        self.max_size = max_size
        self.default_ttl = default_ttl
        
    def get(self, key, default=None):
        """获取缓存数据"""
        if key not in self.cache:
            return default
            
        entry = self.cache[key]
        
        # 检查过期时间
        if time.time() > entry['expires_at']:
            self._remove(key)
            return default
            
        # 更新访问时间
        self.access_times[key] = time.time()
        
        return entry['data']
        
    def set(self, key, data, ttl=None):
        """设置缓存数据"""
        if ttl is None:
            ttl = self.default_ttl
            
        # 检查缓存大小限制
        if len(self.cache) >= self.max_size:
            self._evict_oldest()
            
        self.cache[key] = {
            'data': data,
            'created_at': time.time(),
            'expires_at': time.time() + ttl
        }
        
        self.access_times[key] = time.time()
        
    def _remove(self, key):
        """移除缓存项"""
        self.cache.pop(key, None)
        self.access_times.pop(key, None)
        
    def _evict_oldest(self):
        """淘汰最久未访问的缓存项"""
        if not self.access_times:
            return
            
        oldest_key = min(self.access_times, key=self.access_times.get)
        self._remove(oldest_key)
        
    def clear(self):
        """清空缓存"""
        self.cache.clear()
        self.access_times.clear()
        
    def size(self):
        """获取缓存大小"""
        return len(self.cache)
        
    def cleanup_expired(self):
        """清理过期缓存"""
        current_time = time.time()
        expired_keys = [
            key for key, entry in self.cache.items()
            if current_time > entry['expires_at']
        ]
        
        for key in expired_keys:
            self._remove(key)
            
        return len(expired_keys)
```

## 21.8 实时状态同步

### StatusSynchronizer 实现
```python
class StatusSynchronizer(QObject):
    """状态同步器"""
    
    status_updated = pyqtSignal(str, dict)  # 组件名, 状态数据
    
    def __init__(self, orchestrator_client, parent=None):
        super().__init__(parent)
        self.orchestrator_client = orchestrator_client
        self.sync_timer = QTimer()
        self.sync_interval = 5000  # 5秒同步一次
        
        # 状态监控项
        self.monitored_components = [
            'pob2_integration',
            'data_sources', 
            'rag_system',
            'network_status',
            'system_resources'
        ]
        
        # 连接信号
        self.orchestrator_client.system_health_updated.connect(
            self._on_health_updated
        )
        
        # 启动同步定时器
        self.sync_timer.timeout.connect(self._sync_status)
        self.sync_timer.start(self.sync_interval)
        
    def _sync_status(self):
        """同步状态"""
        # 异步获取系统健康状态
        self.orchestrator_client.get_system_health_async()
        
    def _on_health_updated(self, health_data):
        """健康状态更新处理"""
        for component in self.monitored_components:
            if component in health_data.get('components', {}):
                component_status = health_data['components'][component]
                self.status_updated.emit(component, component_status)
                
    def start_monitoring(self):
        """开始监控"""
        if not self.sync_timer.isActive():
            self.sync_timer.start(self.sync_interval)
            
    def stop_monitoring(self):
        """停止监控"""
        self.sync_timer.stop()
        
    def set_sync_interval(self, interval_ms):
        """设置同步间隔"""
        self.sync_interval = interval_ms
        if self.sync_timer.isActive():
            self.sync_timer.stop()
            self.sync_timer.start(self.sync_interval)
```

请确保数据集成系统实现：
1. 完整的异步任务管理和进度反馈
2. 健壮的错误处理和自动恢复机制
3. 高效的数据缓存和性能优化
4. 实时的状态同步和监控
5. 可靠的数据转换和验证
6. 与现有后端系统的无缝集成

集成系统应该确保GUI与后端的数据流畅通无阻，提供良好的用户体验，同时保持系统的稳定性和性能。