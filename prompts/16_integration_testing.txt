请实现PoE2智能构筑生成器前后端集成和测试：

## 16.1 前后端集成实现

### API集成层 (web/static/js/integration.js)
实现要求：
1. **统一的API客户端**
   - RESTful API调用封装
   - WebSocket连接管理
   - 错误处理和重试机制
   - 请求/响应拦截器

2. **数据流管理**
```javascript
class PoE2DataManager {
    constructor() {
        this.cache = new Map();
        this.api = new PoE2API();
        this.websocket = new PoE2WebSocket();
        this.eventEmitter = new EventEmitter();
    }
    
    // 统一的数据获取接口
    async getData(endpoint, params = {}, useCache = true) {
        const cacheKey = `${endpoint}-${JSON.stringify(params)}`;
        
        if (useCache && this.cache.has(cacheKey)) {
            const cached = this.cache.get(cacheKey);
            if (Date.now() - cached.timestamp < cached.ttl) {
                return cached.data;
            }
        }
        
        try {
            const data = await this.api.request('GET', endpoint, params);
            if (useCache) {
                this.cache.set(cacheKey, {
                    data,
                    timestamp: Date.now(),
                    ttl: this.getTTL(endpoint)
                });
            }
            return data;
        } catch (error) {
            this.handleAPIError(error, endpoint, params);
            throw error;
        }
    }
    
    // 构筑生成完整流程
    async generateBuild(requestData) {
        return new Promise((resolve, reject) => {
            // 监听WebSocket进度更新
            const buildId = this.generateBuildId();
            
            this.websocket.subscribe(buildId, {
                onProgress: (progress, message) => {
                    this.eventEmitter.emit('buildProgress', {
                        buildId,
                        progress,
                        message
                    });
                },
                onComplete: (result) => {
                    this.eventEmitter.emit('buildComplete', result);
                    resolve(result);
                },
                onError: (error) => {
                    this.eventEmitter.emit('buildError', error);
                    reject(error);
                }
            });
            
            // 发起构筑生成请求
            this.api.generateBuilds(requestData, buildId)
                .catch(reject);
        });
    }
}
```

### 状态管理系统
1. **应用状态管理**
```javascript
class PoE2AppState {
    constructor() {
        this.state = {
            // 用户输入状态
            formData: {
                characterClass: null,
                ascendancy: null,
                buildGoal: null,
                budget: { amount: 15, currency: 'divine' },
                preferences: {},
                advanced: {}
            },
            
            // 构筑结果状态
            builds: {
                current: [],
                loading: false,
                error: null,
                filters: {},
                sort: 'relevance'
            },
            
            // 系统状态
            system: {
                health: null,
                components: {},
                lastCheck: null
            },
            
            // UI状态
            ui: {
                activeTab: 'generator',
                showAdvanced: false,
                theme: 'dark',
                notifications: []
            }
        };
        
        this.listeners = new Set();
    }
    
    // 状态更新方法
    updateState(path, value) {
        const oldState = JSON.parse(JSON.stringify(this.state));
        this.setNestedValue(this.state, path, value);
        
        // 通知所有监听器
        this.listeners.forEach(listener => {
            listener(this.state, oldState, path, value);
        });
    }
    
    // 订阅状态变化
    subscribe(listener) {
        this.listeners.add(listener);
        return () => this.listeners.delete(listener);
    }
}
```

2. **响应式数据绑定**
```javascript
class PoE2ReactiveUI {
    constructor(appState) {
        this.state = appState;
        this.bindings = new Map();
        this.setupBindings();
    }
    
    setupBindings() {
        // 表单数据绑定
        this.bindFormElements();
        
        // 结果列表绑定
        this.bindResultsContainer();
        
        // 系统状态绑定
        this.bindSystemStatus();
        
        // 状态变化监听
        this.state.subscribe(this.handleStateChange.bind(this));
    }
    
    bindFormElements() {
        // 职业选择绑定
        document.querySelectorAll('.class-card').forEach(card => {
            card.addEventListener('click', (e) => {
                const className = e.currentTarget.dataset.class;
                this.state.updateState('formData.characterClass', className);
            });
        });
        
        // 预算滑块绑定
        const budgetSlider = document.getElementById('budget-slider');
        if (budgetSlider) {
            budgetSlider.addEventListener('input', (e) => {
                this.state.updateState('formData.budget.amount', e.target.value);
            });
        }
    }
}
```

## 16.2 端到端测试实现

### Web UI自动化测试 (tests/e2e/test_web_ui.py)
使用Selenium进行浏览器自动化测试：

```python
import pytest
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException
import time

class TestPoE2WebUI:
    @pytest.fixture(scope="class")
    def driver(self):
        """设置WebDriver"""
        options = webdriver.ChromeOptions()
        options.add_argument("--headless")  # 无头模式用于CI
        options.add_argument("--no-sandbox")
        options.add_argument("--disable-dev-shm-usage")
        
        driver = webdriver.Chrome(options=options)
        driver.implicitly_wait(10)
        yield driver
        driver.quit()
    
    @pytest.fixture(scope="class")
    def web_server(self):
        """启动Web服务器"""
        import subprocess
        import threading
        import time
        
        # 启动FastAPI服务器
        process = subprocess.Popen([
            "python", "-m", "uvicorn", 
            "src.poe2build.web.app:app",
            "--host", "127.0.0.1",
            "--port", "8080"
        ])
        
        # 等待服务器启动
        time.sleep(3)
        
        yield "http://127.0.0.1:8080"
        
        # 清理
        process.terminate()
        process.wait()
    
    def test_homepage_loads(self, driver, web_server):
        """测试首页加载"""
        driver.get(web_server)
        
        # 验证页面标题
        assert "PoE2 Build Generator" in driver.title
        
        # 验证关键元素存在
        assert driver.find_element(By.ID, "build-generator-form")
        assert driver.find_element(By.CLASS_NAME, "class-grid")
        
    def test_class_selection(self, driver, web_server):
        """测试职业选择功能"""
        driver.get(web_server)
        
        # 点击职业卡片
        class_cards = driver.find_elements(By.CLASS_NAME, "class-card")
        assert len(class_cards) > 0
        
        # 选择第一个职业
        first_class = class_cards[0]
        first_class.click()
        
        # 验证选中状态
        assert "selected" in first_class.get_attribute("class")
        
    def test_build_generation_flow(self, driver, web_server):
        """测试完整的构筑生成流程"""
        driver.get(web_server)
        wait = WebDriverWait(driver, 30)
        
        # 1. 选择职业
        class_card = wait.until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, ".class-card[data-class='Ranger']"))
        )
        class_card.click()
        
        # 2. 选择构筑目标
        goal_button = wait.until(
            EC.element_to_be_clickable((By.CSS_SELECTOR, ".goal-option[data-goal='clear_speed']"))
        )
        goal_button.click()
        
        # 3. 设置预算
        budget_slider = driver.find_element(By.ID, "budget-slider")
        driver.execute_script("arguments[0].value = 20;", budget_slider)
        driver.execute_script("arguments[0].dispatchEvent(new Event('input'));", budget_slider)
        
        # 4. 提交表单
        submit_button = driver.find_element(By.ID, "generate-builds-btn")
        submit_button.click()
        
        # 5. 等待结果
        try:
            # 等待加载完成
            wait.until(EC.presence_of_element_located((By.CLASS_NAME, "loading-spinner")))
            
            # 等待结果显示
            results_container = wait.until(
                EC.presence_of_element_located((By.ID, "builds-container"))
            )
            
            # 验证结果
            build_cards = results_container.find_elements(By.CLASS_NAME, "build-card")
            assert len(build_cards) > 0
            
            # 验证第一个构筑卡片的内容
            first_build = build_cards[0]
            assert first_build.find_element(By.CLASS_NAME, "build-name").text
            assert first_build.find_element(By.CLASS_NAME, "stat-value").text
            
        except TimeoutException:
            # 如果超时，检查是否有错误消息
            error_elements = driver.find_elements(By.CLASS_NAME, "error-message")
            if error_elements:
                pytest.fail(f"构筑生成失败: {error_elements[0].text}")
            else:
                pytest.fail("构筑生成超时")
    
    def test_pob2_export(self, driver, web_server):
        """测试PoB2导出功能"""
        # 首先生成构筑
        self.test_build_generation_flow(driver, web_server)
        
        wait = WebDriverWait(driver, 10)
        
        # 找到导出按钮并点击
        export_button = wait.until(
            EC.element_to_be_clickable((By.CLASS_NAME, "export-pob2"))
        )
        export_button.click()
        
        # 等待导出结果
        pob2_modal = wait.until(
            EC.presence_of_element_located((By.ID, "pob2-export-modal"))
        )
        
        # 验证PoB2代码存在
        pob2_code = pob2_modal.find_element(By.CLASS_NAME, "pob2-code")
        assert len(pob2_code.text) > 0
        assert pob2_code.text.startswith("https://pob.party/")
    
    def test_responsive_design(self, driver, web_server):
        """测试响应式设计"""
        driver.get(web_server)
        
        # 测试不同屏幕尺寸
        screen_sizes = [
            (1920, 1080),  # 桌面
            (768, 1024),   # 平板
            (375, 667)     # 手机
        ]
        
        for width, height in screen_sizes:
            driver.set_window_size(width, height)
            time.sleep(0.5)  # 等待布局调整
            
            # 验证关键元素仍然可见
            class_grid = driver.find_element(By.CLASS_NAME, "class-grid")
            assert class_grid.is_displayed()
            
            form = driver.find_element(By.ID, "build-generator-form")
            assert form.is_displayed()
```

### API集成测试 (tests/integration/test_web_api.py)
```python
import pytest
import asyncio
from fastapi.testclient import TestClient
from src.poe2build.web.app import app
import json

class TestWebAPI:
    @pytest.fixture
    def client(self):
        """创建测试客户端"""
        return TestClient(app)
    
    def test_health_endpoint(self, client):
        """测试健康检查端点"""
        response = client.get("/api/v1/health")
        assert response.status_code == 200
        
        data = response.json()
        assert "status" in data
        assert "components" in data
        assert data["status"] in ["healthy", "degraded", "unhealthy"]
    
    def test_build_generation_endpoint(self, client):
        """测试构筑生成端点"""
        request_data = {
            "character_class": "Ranger",
            "goal": "clear_speed",
            "budget": {
                "amount": 15.0,
                "currency": "divine"
            },
            "preferences": {
                "playstyle": "balanced",
                "damage_type": "physical"
            }
        }
        
        response = client.post("/api/v1/build/generate", json=request_data)
        assert response.status_code == 200
        
        data = response.json()
        assert data["success"] == True
        assert "recommendations" in data
        assert len(data["recommendations"]) > 0
        
        # 验证第一个推荐的结构
        first_build = data["recommendations"][0]
        assert "id" in first_build
        assert "name" in first_build
        assert "character_info" in first_build
        assert "build_stats" in first_build
    
    def test_build_validation_endpoint(self, client):
        """测试构筑验证端点"""
        request_data = {
            "character_class": "InvalidClass",
            "goal": "invalid_goal"
        }
        
        response = client.post("/api/v1/build/validate", json=request_data)
        assert response.status_code == 200
        
        data = response.json()
        assert data["valid"] == False
        assert "errors" in data
        assert len(data["errors"]) > 0
    
    def test_pob2_export_endpoint(self, client):
        """测试PoB2导出端点"""
        # 首先生成一个构筑
        build_request = {
            "character_class": "Witch",
            "goal": "boss_killing",
            "budget": {"amount": 25.0, "currency": "divine"}
        }
        
        build_response = client.post("/api/v1/build/generate", json=build_request)
        assert build_response.status_code == 200
        
        build_data = build_response.json()
        build_id = build_data["recommendations"][0]["id"]
        
        # 导出PoB2代码
        export_response = client.post(f"/api/v1/build/{build_id}/export")
        assert export_response.status_code == 200
        
        export_data = export_response.json()
        assert "pob2_code" in export_data
        assert len(export_data["pob2_code"]) > 0
    
    def test_cors_headers(self, client):
        """测试CORS头设置"""
        response = client.options("/api/v1/health", 
                                headers={"Origin": "http://localhost:3000"})
        
        assert response.headers.get("access-control-allow-origin")
        assert response.headers.get("access-control-allow-methods")
        assert response.headers.get("access-control-allow-headers")
    
    def test_error_handling(self, client):
        """测试错误处理"""
        # 发送无效JSON
        response = client.post("/api/v1/build/generate", 
                             data="invalid json",
                             headers={"Content-Type": "application/json"})
        
        assert response.status_code == 422  # 验证错误
        
        # 发送空请求
        response = client.post("/api/v1/build/generate", json={})
        assert response.status_code == 422
        
        error_data = response.json()
        assert "detail" in error_data
```

### WebSocket测试 (tests/integration/test_websocket.py)
```python
import pytest
import asyncio
import websockets
import json
from src.poe2build.web.app import app
import threading
import time

class TestWebSocket:
    @pytest.fixture
    def websocket_server(self):
        """启动WebSocket服务器"""
        import uvicorn
        import threading
        
        # 在后台线程启动服务器
        def run_server():
            uvicorn.run(app, host="127.0.0.1", port=8081, log_level="error")
        
        server_thread = threading.Thread(target=run_server, daemon=True)
        server_thread.start()
        time.sleep(2)  # 等待服务器启动
        
        yield "ws://127.0.0.1:8081"
    
    @pytest.mark.asyncio
    async def test_build_progress_websocket(self, websocket_server):
        """测试构筑生成进度WebSocket"""
        uri = f"{websocket_server}/ws/build-progress"
        
        try:
            async with websockets.connect(uri) as websocket:
                # 发送订阅消息
                subscribe_msg = {
                    "action": "subscribe",
                    "build_id": "test_build_123"
                }
                await websocket.send(json.dumps(subscribe_msg))
                
                # 等待确认消息
                response = await websocket.recv()
                data = json.loads(response)
                assert data["type"] == "subscribed"
                
                # 模拟进度更新（这需要触发实际的构筑生成）
                # 在实际测试中，我们会并行发起构筑生成请求
                
        except websockets.exceptions.ConnectionClosed:
            pytest.fail("WebSocket连接意外关闭")
    
    @pytest.mark.asyncio
    async def test_system_status_websocket(self, websocket_server):
        """测试系统状态WebSocket"""
        uri = f"{websocket_server}/ws/system-status"
        
        try:
            async with websockets.connect(uri) as websocket:
                # 等待状态更新
                response = await asyncio.wait_for(websocket.recv(), timeout=5.0)
                data = json.loads(response)
                
                assert "type" in data
                assert data["type"] in ["system_status", "component_update"]
                
        except asyncio.TimeoutError:
            # 如果没有状态更新也是正常的
            pass
        except websockets.exceptions.ConnectionClosed:
            pytest.fail("WebSocket连接意外关闭")
```

## 16.3 性能测试

### 前端性能测试 (tests/performance/test_frontend_performance.py)
```python
import pytest
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
import time
import json

class TestFrontendPerformance:
    @pytest.fixture
    def performance_driver(self):
        """配置性能测试专用的WebDriver"""
        options = Options()
        options.add_argument("--enable-logging")
        options.add_argument("--log-level=0")
        
        # 启用性能日志
        caps = {
            "goog:loggingPrefs": {"performance": "ALL"}
        }
        options.add_experimental_option("perfLoggingPrefs", {
            "enableNetwork": True,
            "enablePage": True
        })
        
        driver = webdriver.Chrome(options=options)
        yield driver
        driver.quit()
    
    def test_page_load_performance(self, performance_driver, web_server):
        """测试页面加载性能"""
        start_time = time.time()
        performance_driver.get(web_server)
        
        # 等待页面完全加载
        performance_driver.execute_script("return document.readyState") == "complete"
        load_time = time.time() - start_time
        
        # 页面应该在3秒内加载完成
        assert load_time < 3.0, f"页面加载时间过长: {load_time:.2f}秒"
        
        # 获取性能指标
        performance_logs = performance_driver.get_log("performance")
        navigation_timing = performance_driver.execute_script(
            "return window.performance.timing"
        )
        
        # 计算关键指标
        dom_ready = navigation_timing["domContentLoadedEventEnd"] - navigation_timing["navigationStart"]
        page_load = navigation_timing["loadEventEnd"] - navigation_timing["navigationStart"]
        
        assert dom_ready < 2000, f"DOM准备时间过长: {dom_ready}ms"
        assert page_load < 3000, f"页面加载时间过长: {page_load}ms"
    
    def test_build_generation_performance(self, performance_driver, web_server):
        """测试构筑生成性能"""
        performance_driver.get(web_server)
        
        # 执行构筑生成流程
        start_time = time.time()
        
        # 选择职业和配置
        class_card = performance_driver.find_element(By.CSS_SELECTOR, ".class-card[data-class='Ranger']")
        class_card.click()
        
        goal_button = performance_driver.find_element(By.CSS_SELECTOR, ".goal-option[data-goal='clear_speed']")
        goal_button.click()
        
        submit_button = performance_driver.find_element(By.ID, "generate-builds-btn")
        submit_button.click()
        
        # 等待结果
        wait = WebDriverWait(performance_driver, 30)
        wait.until(EC.presence_of_element_located((By.CLASS_NAME, "build-card")))
        
        total_time = time.time() - start_time
        
        # 构筑生成应该在15秒内完成
        assert total_time < 15.0, f"构筑生成时间过长: {total_time:.2f}秒"
    
    def test_memory_usage(self, performance_driver, web_server):
        """测试内存使用"""
        performance_driver.get(web_server)
        
        # 获取初始内存使用
        initial_memory = performance_driver.execute_script(
            "return window.performance.memory.usedJSHeapSize"
        )
        
        # 执行多次操作
        for i in range(5):
            # 生成构筑
            class_card = performance_driver.find_element(By.CSS_SELECTOR, ".class-card[data-class='Witch']")
            class_card.click()
            
            submit_button = performance_driver.find_element(By.ID, "generate-builds-btn")
            submit_button.click()
            
            # 等待结果
            wait = WebDriverWait(performance_driver, 10)
            wait.until(EC.presence_of_element_located((By.CLASS_NAME, "build-card")))
            
            time.sleep(1)
        
        # 获取最终内存使用
        final_memory = performance_driver.execute_script(
            "return window.performance.memory.usedJSHeapSize"
        )
        
        memory_increase = final_memory - initial_memory
        memory_mb = memory_increase / 1024 / 1024
        
        # 内存增长不应超过50MB
        assert memory_mb < 50, f"内存使用增长过多: {memory_mb:.2f}MB"
```

## 16.4 用户体验测试

### 可访问性测试
1. **键盘导航测试**
2. **屏幕阅读器兼容性测试**
3. **色彩对比度测试**
4. **响应式设计测试**

### 跨浏览器测试
1. **Chrome/Firefox/Safari兼容性**
2. **移动浏览器测试**
3. **不同屏幕分辨率测试**

请确保集成测试：
1. 完整的端到端用户流程测试
2. API和WebSocket功能测试
3. 前端性能和用户体验测试
4. 错误处理和边界情况测试
5. 跨平台和浏览器兼容性测试
6. 自动化测试和CI集成
7. 生产环境部署验证

实现时请确保测试覆盖所有关键功能，包括构筑生成、结果展示、PoB2导出等核心流程，以及错误处理和降级服务的各种场景。